{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst is_1 = require(\"@sindresorhus/is\");\n\nconst assert = require(\"assert\");\n\nconst consoleLogLevel = require(\"console-log-level\");\n\nconst crypto = require(\"crypto\");\n\nconst events_1 = require(\"events\");\n\nconst extend = require(\"extend\");\n\nconst fs = require(\"fs\");\n\nconst metadata = require(\"gcp-metadata\");\n\nconst path = require(\"path\");\n\nconst util = require(\"util\");\n\nconst status_message_1 = require(\"../client/stackdriver/status-message\");\n\nconst debuggee_1 = require(\"../debuggee\");\n\nconst config_1 = require(\"./config\");\n\nconst controller_1 = require(\"./controller\");\n\nconst scanner = require(\"./io/scanner\");\n\nconst SourceMapper = require(\"./io/sourcemapper\");\n\nconst utils = require(\"./util/utils\");\n\nconst debugapi = require(\"./v8/debugapi\");\n\nconst readFilep = util.promisify(fs.readFile);\nconst ALLOW_EXPRESSIONS_MESSAGE = 'Expressions and conditions are not allowed' + ' by default. Please set the allowExpressions configuration option to true.' + ' See the debug agent documentation at https://goo.gl/ShSm6r.';\nconst NODE_VERSION_MESSAGE = 'Node.js version not supported. Node.js 5.2.0 and ' + 'versions older than 0.12 are not supported.';\nconst NODE_10_CIRC_REF_MESSAGE = 'capture.maxDataSize=0 is not recommended on older versions of Node' + ' 10/11. See https://github.com/googleapis/cloud-debug-nodejs/issues/516' + ' for more information.';\nconst BREAKPOINT_ACTION_MESSAGE = 'The only currently supported breakpoint actions' + ' are CAPTURE and LOG.'; // PROMISE_RESOLVE_CUT_OFF_IN_MILLISECONDS is a heuristic duration that we set\n// to force the debug agent to return a new promise for isReady. The value is\n// the average of Stackdriver debugger hanging get duration (40s) and TCP\n// time-out on GCF (540s).\n\nconst PROMISE_RESOLVE_CUT_OFF_IN_MILLISECONDS = (40 + 540) / 2 * 1000;\n/**\n * Formats a breakpoint object prefixed with a provided message as a string\n * intended for logging.\n * @param {string} msg The message that prefixes the formatted breakpoint.\n * @param {Breakpoint} breakpoint The breakpoint to format.\n * @return {string} A formatted string.\n */\n\nconst formatBreakpoint = (msg, breakpoint) => {\n  let text = msg + util.format('breakpoint id: %s,\\n\\tlocation: %s', breakpoint.id, util.inspect(breakpoint.location));\n\n  if (breakpoint.createdTime) {\n    const unixTime = Number(breakpoint.createdTime.seconds);\n    const date = new Date(unixTime * 1000); // to milliseconds.\n\n    text += '\\n\\tcreatedTime: ' + date.toString();\n  }\n\n  if (breakpoint.condition) {\n    text += '\\n\\tcondition: ' + util.inspect(breakpoint.condition);\n  }\n\n  if (breakpoint.expressions) {\n    text += '\\n\\texpressions: ' + util.inspect(breakpoint.expressions);\n  }\n\n  return text;\n};\n/**\n * Formats a map of breakpoint objects prefixed with a provided message as a\n * string intended for logging.\n * @param {string} msg The message that prefixes the formatted breakpoint.\n * @param {Object.<string, Breakpoint>} breakpoints A map of breakpoints.\n * @return {string} A formatted string.\n */\n\n\nconst formatBreakpoints = (msg, breakpoints) => {\n  return msg + Object.keys(breakpoints).map(b => {\n    return formatBreakpoint('', breakpoints[b]);\n  }).join('\\n');\n};\n/**\n * CachedPromise stores a promise. This promise can be resolved by calling\n * function resolve() and can only be resolved once.\n */\n\n\nclass CachedPromise {\n  constructor() {\n    this.promiseResolve = null;\n    this.promise = new Promise(resolve => {\n      this.promiseResolve = resolve;\n    });\n  }\n\n  get() {\n    return this.promise;\n  }\n\n  resolve() {\n    // Each promise can be resolved only once.\n    if (this.promiseResolve) {\n      this.promiseResolve();\n      this.promiseResolve = null;\n    }\n  }\n\n}\n\nexports.CachedPromise = CachedPromise;\n/**\n * IsReadyManager is a wrapper class to use debuglet.isReady().\n */\n\nclass IsReadyImpl {\n  constructor(debuglet) {\n    this.debuglet = debuglet;\n  }\n\n  isReady() {\n    return this.debuglet.isReady();\n  }\n\n}\n\nclass Debuglet extends events_1.EventEmitter {\n  /**\n   * @param {Debug} debug - A Debug instance.\n   * @param {object=} config - The option parameters for the Debuglet.\n   * @event 'started' once the startup tasks are completed. Only called once.\n   * @event 'stopped' if the agent stops due to a fatal error after starting.\n   * Only called once.\n   * @event 'registered' once successfully registered to the debug api. May be\n   *     emitted multiple times.\n   * @event 'remotelyDisabled' if the debuggee is disabled by the server. May be\n   *    called multiple times.\n   * @constructor\n   */\n  constructor(debug, config) {\n    super();\n    this.isReadyManager = new IsReadyImpl(this);\n    /** @private {object} */\n\n    this.config = Debuglet.normalizeConfig_(config);\n    /** @private {Debug} */\n\n    this.debug = debug;\n    /**\n     * @private {object} V8 Debug API. This can be null if the Node.js version\n     *     is out of date.\n     */\n\n    this.v8debug = null;\n    /** @private {boolean} */\n\n    this.running = false;\n    /** @private {string} */\n\n    this.project = null;\n    /** @private {boolean} */\n\n    this.fetcherActive = false;\n    /** @private */\n\n    this.logger = consoleLogLevel({\n      stderr: true,\n      prefix: this.debug.packageInfo.name,\n      level: Debuglet.logLevelToName(this.config.logLevel)\n    });\n    /** @private {DebugletApi} */\n\n    this.controller = new controller_1.Controller(this.debug, {\n      apiUrl: config.apiUrl\n    });\n    /** @private {Debuggee} */\n\n    this.debuggee = null;\n    /** @private {Object.<string, Breakpoint>} */\n\n    this.activeBreakpointMap = {};\n    /** @private {Object.<string, Boolean>} */\n\n    this.completedBreakpointMap = {};\n    this.breakpointFetched = null;\n    this.breakpointFetchedTimestamp = -Infinity;\n    this.debuggeeRegistered = new CachedPromise();\n  } // The return type `LogLevel` is used instead of\n  // `consoleLogLevel.LogLevelNames` because, otherwise,\n  // the `consoleLogLevel.LogLevelNames` type is exposed to\n  // users of the debug agent, requiring them to have\n  // @types/console-log-level installed to compile their code.\n\n\n  static logLevelToName(level) {\n    if (typeof level === 'string') {\n      level = Number(level);\n    }\n\n    if (typeof level !== 'number') {\n      level = config_1.defaultConfig.logLevel;\n    }\n\n    if (level < 0) level = 0;\n    if (level > 4) level = 4;\n    return Debuglet.LEVELNAMES[level];\n  }\n\n  static normalizeConfig_(config) {\n    const envConfig = {\n      logLevel: process.env.GCLOUD_DEBUG_LOGLEVEL,\n      serviceContext: {\n        service: process.env.GAE_SERVICE || process.env.GAE_MODULE_NAME || process.env.K_SERVICE,\n        version: process.env.GAE_VERSION || process.env.GAE_MODULE_VERSION || process.env.K_REVISION,\n        minorVersion_: process.env.GAE_DEPLOYMENT_ID || process.env.GAE_MINOR_VERSION\n      }\n    };\n\n    if (process.env.FUNCTION_NAME) {\n      envConfig.serviceContext.service = process.env.FUNCTION_NAME;\n      envConfig.serviceContext.version = 'unversioned';\n    }\n\n    return extend(true, {}, config_1.defaultConfig, config, envConfig);\n  }\n\n  static async findFiles(baseDir, precomputedHash) {\n    const fileStats = await scanner.scan(baseDir, /.js$|.js.map$/, precomputedHash);\n    const jsStats = fileStats.selectStats(/.js$/);\n    const mapFiles = fileStats.selectFiles(/.js.map$/, process.cwd());\n    const errors = fileStats.errors();\n    return {\n      jsStats,\n      mapFiles,\n      errors,\n      hash: fileStats.hash\n    };\n  }\n  /**\n   * Starts the Debuglet. It is important that this is as quick as possible\n   * as it is on the critical path of application startup.\n   * @private\n   */\n\n\n  async start() {\n    const that = this;\n    const stat = util.promisify(fs.stat);\n\n    try {\n      await stat(path.join(that.config.workingDirectory, 'package.json'));\n    } catch (err) {\n      that.logger.error('No package.json located in working directory.');\n      that.emit('initError', new Error('No package.json found.'));\n      return;\n    }\n\n    const workingDir = that.config.workingDirectory; // Don't continue if the working directory is a root directory\n    // unless the user wants to force using the root directory\n\n    if (!that.config.allowRootAsWorkingDirectory && path.join(workingDir, '..') === workingDir) {\n      const message = 'The working directory is a root directory. Disabling ' + 'to avoid a scan of the entire filesystem for JavaScript files. ' + 'Use config `allowRootAsWorkingDirectory` if you really want to ' + 'do this.';\n      that.logger.error(message);\n      that.emit('initError', new Error(message));\n      return;\n    }\n\n    let gaeId;\n\n    if (process.env.GAE_MINOR_VERSION) {\n      gaeId = 'GAE-' + process.env.GAE_MINOR_VERSION;\n    }\n\n    let findResults;\n\n    try {\n      findResults = await Debuglet.findFiles(that.config.workingDirectory, gaeId);\n      findResults.errors.forEach(that.logger.warn);\n    } catch (err) {\n      that.logger.error('Error scanning the filesystem.', err);\n      that.emit('initError', err);\n      return;\n    }\n\n    let mapper;\n\n    try {\n      mapper = await SourceMapper.create(findResults.mapFiles);\n    } catch (err3) {\n      that.logger.error('Error processing the sourcemaps.', err3);\n      that.emit('initError', err3);\n      return;\n    }\n\n    that.v8debug = debugapi.create(that.logger, that.config, findResults.jsStats, mapper);\n    const id = gaeId || findResults.hash;\n    that.logger.info('Unique ID for this Application: ' + id);\n    let onGCP;\n\n    try {\n      onGCP = await Debuglet.runningOnGCP();\n    } catch (err) {\n      that.logger.warn('Unexpected error detecting GCE metadata service: ' + err.message); // Continue, assuming not on GCP.\n\n      onGCP = false;\n    }\n\n    let project;\n\n    try {\n      project = await that.debug.authClient.getProjectId();\n    } catch (err) {\n      that.logger.error('The project ID could not be determined: ' + err.message);\n      that.emit('initError', err);\n      return;\n    }\n\n    if (onGCP && (!that.config.serviceContext || !that.config.serviceContext.service)) {\n      // If on GCP, check if the clusterName instance attribute is availble.\n      // Use this as the service context for better service identification on\n      // GKE.\n      try {\n        const clusterName = await Debuglet.getClusterNameFromMetadata();\n        that.config.serviceContext = {\n          service: clusterName,\n          version: 'unversioned',\n          minorVersion_: undefined\n        };\n      } catch (err) {\n        /* we are not running on GKE - Ignore error. */\n      }\n    }\n\n    let sourceContext;\n\n    try {\n      sourceContext = that.config.sourceContext || (await Debuglet.getSourceContextFromFile());\n    } catch (err5) {\n      that.logger.warn('Unable to discover source context', err5); // This is ignorable.\n    }\n\n    if (this.config.capture && this.config.capture.maxDataSize === 0 && utils.satisfies(process.version, '>=10 <10.15.3 || >=11 <11.7')) {\n      that.logger.warn(NODE_10_CIRC_REF_MESSAGE);\n    } // We can register as a debuggee now.\n\n\n    that.logger.debug('Starting debuggee, project', project);\n    that.running = true;\n    that.project = project;\n    that.debuggee = Debuglet.createDebuggee(project, id, that.config.serviceContext, sourceContext, onGCP, that.debug.packageInfo, that.config.description, undefined);\n    that.scheduleRegistration_(0\n    /* immediately */\n    );\n    that.emit('started');\n  }\n  /**\n   * isReady returns a promise that only resolved if the last breakpoint update\n   * happend within a duration (PROMISE_RESOLVE_CUT_OFF_IN_MILLISECONDS). This\n   * feature is mainly used in Google Cloud Function (GCF), as it is a\n   * serverless environment and we wanted to make sure debug agent always\n   * captures the snapshots.\n   */\n\n\n  isReady() {\n    if (Date.now() < this.breakpointFetchedTimestamp + PROMISE_RESOLVE_CUT_OFF_IN_MILLISECONDS) {\n      return Promise.resolve();\n    } else {\n      if (this.breakpointFetched) return this.breakpointFetched.get();\n      this.breakpointFetched = new CachedPromise();\n      this.debuggeeRegistered.get().then(() => {\n        this.scheduleBreakpointFetch_(0\n        /*immediately*/\n        , true\n        /*only fetch once*/\n        );\n      });\n      return this.breakpointFetched.get();\n    }\n  }\n  /**\n   * @private\n   */\n  // TODO: Determine the type of sourceContext\n\n\n  static createDebuggee(projectId, uid, serviceContext, sourceContext, onGCP, packageInfo, description, errorMessage) {\n    const cwd = process.cwd();\n    const mainScript = path.relative(cwd, process.argv[1]);\n    const version = 'google.com/node-' + (onGCP ? 'gcp' : 'standalone') + '/v' + packageInfo.version;\n    let desc = process.title + ' ' + mainScript;\n    const labels = {\n      'main script': mainScript,\n      'process.title': process.title,\n      'node version': process.versions.node,\n      'V8 version': process.versions.v8,\n      'agent.name': packageInfo.name,\n      'agent.version': packageInfo.version,\n      projectid: projectId\n    };\n\n    if (serviceContext) {\n      if (is_1.default.string(serviceContext.service) && serviceContext.service !== 'default') {\n        // As per app-engine-ids, the module label is not reported\n        // when it happens to be 'default'.\n        labels.module = serviceContext.service;\n        desc += ' module:' + serviceContext.service;\n      }\n\n      if (is_1.default.string(serviceContext.version)) {\n        labels.version = serviceContext.version;\n        desc += ' version:' + serviceContext.version;\n      }\n\n      if (is_1.default.string(serviceContext.minorVersion_)) {\n        //          v--- intentional lowercase\n        labels.minorversion = serviceContext.minorVersion_;\n      }\n    }\n\n    if (!description && process.env.FUNCTION_NAME) {\n      description = 'Function: ' + process.env.FUNCTION_NAME;\n    }\n\n    if (description) {\n      desc += ' description:' + description;\n    }\n\n    const uniquifier = Debuglet._createUniquifier(desc, version, uid, sourceContext, labels);\n\n    const statusMessage = errorMessage ? new status_message_1.StatusMessage(status_message_1.StatusMessage.UNSPECIFIED, errorMessage, true) : undefined;\n    const properties = {\n      project: projectId,\n      uniquifier,\n      description: desc,\n      agentVersion: version,\n      labels,\n      statusMessage,\n      packageInfo\n    };\n\n    if (sourceContext) {\n      properties.sourceContexts = [sourceContext];\n    }\n\n    return new debuggee_1.Debuggee(properties);\n  }\n\n  static runningOnGCP() {\n    return metadata.isAvailable();\n  }\n\n  static async getClusterNameFromMetadata() {\n    return (await metadata.instance('attributes/cluster-name')).data;\n  }\n\n  static async getSourceContextFromFile() {\n    // If read errors, the error gets thrown to the caller.\n    const contents = await readFilep('source-context.json', 'utf8');\n\n    try {\n      return JSON.parse(contents);\n    } catch (e) {\n      throw new Error('Malformed source-context.json file: ' + e);\n    }\n  }\n  /**\n   * @param {number} seconds\n   * @private\n   */\n\n\n  scheduleRegistration_(seconds) {\n    const that = this;\n\n    function onError(err) {\n      that.logger.error('Failed to re-register debuggee ' + that.project + ': ' + err);\n      that.scheduleRegistration_(Math.min((seconds + 1) * 2, that.config.internal.maxRegistrationRetryDelay));\n    }\n\n    setTimeout(() => {\n      if (!that.running) {\n        onError(new Error('Debuglet not running'));\n        return;\n      } // TODO: Handle the case when `that.debuggee` is null.\n\n\n      that.controller.register(that.debuggee, (err, result) => {\n        if (err) {\n          onError(err);\n          return;\n        } // TODO: It appears that the Debuggee class never has an\n        // `isDisabled`\n        //       field set.  Determine if this is a bug or if the following\n        //       code is not needed.\n        // TODO: Handle the case when `result` is undefined.\n\n\n        if (result.debuggee.isDisabled) {\n          // Server has disabled this debuggee / debug agent.\n          onError(new Error('Disabled by the server'));\n          that.emit('remotelyDisabled');\n          return;\n        } // TODO: Handle the case when `result` is undefined.\n\n\n        that.logger.info('Registered as debuggee:', result.debuggee.id); // TODO: Handle the case when `that.debuggee` is null.\n        // TODO: Handle the case when `result` is undefined.\n\n        that.debuggee.id = result.debuggee.id; // TODO: Handle the case when `result` is undefined.\n\n        that.emit('registered', result.debuggee.id);\n        that.debuggeeRegistered.resolve();\n\n        if (!that.fetcherActive) {\n          that.scheduleBreakpointFetch_(0, false);\n        }\n      });\n    }, seconds * 1000).unref();\n  }\n  /**\n   * @param {number} seconds\n   * @param {boolean} once\n   * @private\n   */\n\n\n  scheduleBreakpointFetch_(seconds, once) {\n    const that = this;\n\n    if (!once) {\n      that.fetcherActive = true;\n    }\n\n    setTimeout(() => {\n      if (!that.running) {\n        return;\n      }\n\n      if (!once) {\n        assert(that.fetcherActive);\n      }\n\n      that.logger.info('Fetching breakpoints'); // TODO: Address the case when `that.debuggee` is `null`.\n\n      that.controller.listBreakpoints(that.debuggee, (err, response, body) => {\n        if (err) {\n          that.logger.error('Unable to fetch breakpoints â€“ stopping fetcher', err);\n          that.fetcherActive = false; // We back-off from fetching breakpoints, and try to register\n          // again after a while. Successful registration will restart the\n          // breakpoint fetcher.\n\n          that.updatePromise();\n          that.scheduleRegistration_(that.config.internal.registerDelayOnFetcherErrorSec);\n          return;\n        } // TODO: Address the case where `response` is `undefined`.\n\n\n        switch (response.statusCode) {\n          case 404:\n            // Registration expired. Deactivate the fetcher and queue\n            // re-registration, which will re-active breakpoint fetching.\n            that.logger.info('\\t404 Registration expired.');\n            that.fetcherActive = false;\n            that.updatePromise();\n            that.scheduleRegistration_(0\n            /*immediately*/\n            );\n            return;\n\n          default:\n            // TODO: Address the case where `response` is `undefined`.\n            that.logger.info('\\t' + response.statusCode + ' completed.');\n\n            if (!body) {\n              that.logger.error('\\tinvalid list response: empty body');\n              that.scheduleBreakpointFetch_(that.config.breakpointUpdateIntervalSec, once);\n              return;\n            }\n\n            if (body.waitExpired) {\n              that.logger.info('\\tLong poll completed.');\n              that.scheduleBreakpointFetch_(0\n              /*immediately*/\n              , once);\n              return;\n            }\n\n            const bps = (body.breakpoints || []).filter(bp => {\n              const action = bp.action || 'CAPTURE';\n\n              if (action !== 'CAPTURE' && action !== 'LOG') {\n                that.logger.warn('Found breakpoint with invalid action:', action);\n                bp.status = new status_message_1.StatusMessage(status_message_1.StatusMessage.UNSPECIFIED, BREAKPOINT_ACTION_MESSAGE, true);\n                that.rejectBreakpoint_(bp);\n                return false;\n              }\n\n              return true;\n            });\n            that.updateActiveBreakpoints_(bps);\n\n            if (Object.keys(that.activeBreakpointMap).length) {\n              that.logger.info(formatBreakpoints('Active Breakpoints: ', that.activeBreakpointMap));\n            }\n\n            that.breakpointFetchedTimestamp = Date.now();\n\n            if (once) {\n              if (that.breakpointFetched) {\n                that.breakpointFetched.resolve();\n                that.breakpointFetched = null;\n              }\n            } else {\n              that.scheduleBreakpointFetch_(that.config.breakpointUpdateIntervalSec, once);\n            }\n\n            return;\n        }\n      });\n    }, seconds * 1000).unref();\n  }\n  /**\n   * updatePromise_ is called when debuggee is expired. debuggeeRegistered\n   * CachedPromise will be refreshed. Also, breakpointFetched CachedPromise will\n   * be resolved so that uses (such as GCF users) will not hang forever to wait\n   * non-fetchable breakpoints.\n   */\n\n\n  updatePromise() {\n    this.debuggeeRegistered = new CachedPromise();\n\n    if (this.breakpointFetched) {\n      this.breakpointFetched.resolve();\n      this.breakpointFetched = null;\n    }\n  }\n  /**\n   * Given a list of server breakpoints, update our internal list of breakpoints\n   * @param {Array.<Breakpoint>} breakpoints\n   * @private\n   */\n\n\n  updateActiveBreakpoints_(breakpoints) {\n    const that = this;\n    const updatedBreakpointMap = this.convertBreakpointListToMap_(breakpoints);\n\n    if (breakpoints.length) {\n      that.logger.info(formatBreakpoints('Server breakpoints: ', updatedBreakpointMap));\n    }\n\n    breakpoints.forEach(breakpoint => {\n      // TODO: Address the case when `breakpoint.id` is `undefined`.\n      if (!that.completedBreakpointMap[breakpoint.id] && !that.activeBreakpointMap[breakpoint.id]) {\n        // New breakpoint\n        that.addBreakpoint_(breakpoint, err => {\n          if (err) {\n            that.completeBreakpoint_(breakpoint, false);\n          }\n        }); // Schedule the expiry of server breakpoints.\n\n        that.scheduleBreakpointExpiry_(breakpoint);\n      }\n    }); // Remove completed breakpoints that the server no longer cares about.\n\n    Debuglet.mapSubtract(this.completedBreakpointMap, updatedBreakpointMap).forEach(breakpoint => {\n      // TODO: FIXME: breakpoint is a boolean here that doesn't have an id\n      //              field.  It is possible that breakpoint.id is always\n      //              undefined!\n      // TODO: Make sure the use of `that` here is correct.\n      delete that.completedBreakpointMap[breakpoint.id];\n    }); // Remove active breakpoints that the server no longer care about.\n\n    Debuglet.mapSubtract(this.activeBreakpointMap, updatedBreakpointMap).forEach(bp => {\n      this.removeBreakpoint_(bp, true);\n    });\n  }\n  /**\n   * Array of breakpints get converted to Map of breakpoints, indexed by id\n   * @param {Array.<Breakpoint>} breakpointList\n   * @return {Object.<string, Breakpoint>} A map of breakpoint IDs to breakpoints.\n   * @private\n   */\n\n\n  convertBreakpointListToMap_(breakpointList) {\n    const map = {};\n    breakpointList.forEach(breakpoint => {\n      // TODO: Address the case when `breakpoint.id` is `undefined`.\n      map[breakpoint.id] = breakpoint;\n    });\n    return map;\n  }\n  /**\n   * @param {Breakpoint} breakpoint\n   * @private\n   */\n\n\n  removeBreakpoint_(breakpoint, deleteFromV8) {\n    this.logger.info('\\tdeleted breakpoint', breakpoint.id); // TODO: Address the case when `breakpoint.id` is `undefined`.\n\n    delete this.activeBreakpointMap[breakpoint.id];\n\n    if (deleteFromV8 && this.v8debug) {\n      this.v8debug.clear(breakpoint, err => {\n        if (err) this.logger.error(err);\n      });\n    }\n  }\n  /**\n   * @param {Breakpoint} breakpoint\n   * @return {boolean} false on error\n   * @private\n   */\n\n\n  addBreakpoint_(breakpoint, cb) {\n    const that = this;\n\n    if (!that.config.allowExpressions && (breakpoint.condition || breakpoint.expressions)) {\n      that.logger.error(ALLOW_EXPRESSIONS_MESSAGE);\n      breakpoint.status = new status_message_1.StatusMessage(status_message_1.StatusMessage.UNSPECIFIED, ALLOW_EXPRESSIONS_MESSAGE, true);\n      setImmediate(() => {\n        cb(ALLOW_EXPRESSIONS_MESSAGE);\n      });\n      return;\n    }\n\n    if (utils.satisfies(process.version, '5.2 || <4')) {\n      const message = NODE_VERSION_MESSAGE;\n      that.logger.error(message);\n      breakpoint.status = new status_message_1.StatusMessage(status_message_1.StatusMessage.UNSPECIFIED, message, true);\n      setImmediate(() => {\n        cb(message);\n      });\n      return;\n    } // TODO: Address the case when `that.v8debug` is `null`.\n\n\n    that.v8debug.set(breakpoint, err1 => {\n      if (err1) {\n        cb(err1);\n        return;\n      }\n\n      that.logger.info('\\tsuccessfully added breakpoint  ' + breakpoint.id); // TODO: Address the case when `breakpoint.id` is `undefined`.\n\n      that.activeBreakpointMap[breakpoint.id] = breakpoint;\n\n      if (breakpoint.action === 'LOG') {\n        // TODO: Address the case when `that.v8debug` is `null`.\n        that.v8debug.log(breakpoint, (fmt, exprs) => {\n          that.config.log.logFunction(\"LOGPOINT: \".concat(Debuglet.format(fmt, exprs)));\n        }, () => {\n          // TODO: Address the case when `breakpoint.id` is `undefined`.\n          return that.completedBreakpointMap[breakpoint.id];\n        });\n      } else {\n        // TODO: Address the case when `that.v8debug` is `null`.\n        that.v8debug.wait(breakpoint, err2 => {\n          if (err2) {\n            that.logger.error(err2);\n            cb(err2);\n            return;\n          }\n\n          that.logger.info('Breakpoint hit!: ' + breakpoint.id);\n          that.completeBreakpoint_(breakpoint);\n        });\n      }\n    });\n  }\n  /**\n   * Update the server that the breakpoint has been completed (captured, or\n   * expired).\n   * @param {Breakpoint} breakpoint\n   * @private\n   */\n\n\n  completeBreakpoint_(breakpoint, deleteFromV8 = true) {\n    const that = this;\n    that.logger.info('\\tupdating breakpoint data on server', breakpoint.id);\n    that.controller.updateBreakpoint( // TODO: Address the case when `that.debuggee` is `null`.\n    that.debuggee, breakpoint, (err\n    /*, body*/\n    ) => {\n      if (err) {\n        that.logger.error('Unable to complete breakpoint on server', err);\n      } else {\n        // TODO: Address the case when `breakpoint.id` is `undefined`.\n        that.completedBreakpointMap[breakpoint.id] = true;\n        that.removeBreakpoint_(breakpoint, deleteFromV8);\n      }\n    });\n  }\n  /**\n   * Update the server that the breakpoint cannot be handled.\n   * @param {Breakpoint} breakpoint\n   * @private\n   */\n\n\n  rejectBreakpoint_(breakpoint) {\n    const that = this; // TODO: Address the case when `that.debuggee` is `null`.\n\n    that.controller.updateBreakpoint(that.debuggee, breakpoint, (err\n    /*, body*/\n    ) => {\n      if (err) {\n        that.logger.error('Unable to complete breakpoint on server', err);\n      }\n    });\n  }\n  /**\n   * This schedules a delayed operation that will delete the breakpoint from the\n   * server after the expiry period.\n   * FIXME: we should cancel the timer when the breakpoint completes. Otherwise\n   * we hold onto the closure memory until the breapointExpirateion timeout.\n   * @param {Breakpoint} breakpoint Server breakpoint object\n   * @private\n   */\n\n\n  scheduleBreakpointExpiry_(breakpoint) {\n    const that = this;\n    const now = Date.now() / 1000;\n    const createdTime = breakpoint.createdTime ? Number(breakpoint.createdTime.seconds) : now;\n    const expiryTime = createdTime + that.config.breakpointExpirationSec;\n    setTimeout(() => {\n      that.logger.info('Expiring breakpoint ' + breakpoint.id);\n      breakpoint.status = {\n        description: {\n          format: 'The snapshot has expired'\n        },\n        isError: true,\n        refersTo: status_message_1.StatusMessage.BREAKPOINT_AGE\n      };\n      that.completeBreakpoint_(breakpoint);\n    }, (expiryTime - now) * 1000).unref();\n  }\n  /**\n   * Stops the Debuglet. This is for testing purposes only. Stop should only be\n   * called on a agent that has started (i.e. emitted the 'started' event).\n   * Calling this while the agent is initializing may not necessarily stop all\n   * pending operations.\n   */\n\n\n  stop() {\n    assert.ok(this.running, 'stop can only be called on a running agent');\n    this.logger.debug('Stopping Debuglet');\n    this.running = false;\n    this.emit('stopped');\n  }\n  /**\n   * Performs a set subtract. Returns A - B given maps A, B.\n   * @return {Array.<Breakpoint>} A array containing elements from A that are not\n   *     in B.\n   */\n  // TODO: Determine if this can be generic\n  // TODO: The code that uses this actually assumes the supplied arguments\n  //       are objects and used as an associative array.  Determine what is\n  //       correct (the code or the docs).\n  // TODO: Fix the docs because the code actually assumes that the values\n  //       of the keys in the supplied arguments have boolean values or\n  //       Breakpoint values.\n\n\n  static mapSubtract(A, B) {\n    const removed = [];\n\n    for (const key in A) {\n      if (!B[key]) {\n        removed.push(A[key]);\n      }\n    }\n\n    return removed;\n  }\n  /**\n   * Formats the message base with placeholders `$0`, `$1`, etc\n   * by substituting the provided expressions. If more expressions\n   * are given than placeholders extra expressions are dropped.\n   */\n\n\n  static format(base, exprs) {\n    const tokens = Debuglet._tokenize(base, exprs.length);\n\n    for (let i = 0; i < tokens.length; i++) {\n      // TODO: Determine how to remove this explicit cast\n      if (!tokens[i].v) {\n        continue;\n      } // TODO: Determine how to not have an explicit cast here\n\n\n      if (tokens[i].v === '$$') {\n        tokens[i] = '$';\n        continue;\n      }\n\n      for (let j = 0; j < exprs.length; j++) {\n        // TODO: Determine how to not have an explicit cast here\n        if (tokens[i].v === '$' + j) {\n          tokens[i] = exprs[j];\n          break;\n        }\n      }\n    }\n\n    return tokens.join('');\n  }\n\n  static _tokenize(base, exprLength) {\n    let acc = Debuglet._delimit(base, '$$');\n\n    for (let i = exprLength - 1; i >= 0; i--) {\n      const newAcc = [];\n\n      for (let j = 0; j < acc.length; j++) {\n        // TODO: Determine how to remove this explicit cast\n        if (acc[j].v) {\n          newAcc.push(acc[j]);\n        } else {\n          // TODO: Determine how to not have an explicit cast to string here\n          newAcc.push.apply(newAcc, Debuglet._delimit(acc[j], '$' + i));\n        }\n      }\n\n      acc = newAcc;\n    }\n\n    return acc;\n  }\n\n  static _delimit(source, delim) {\n    const pieces = source.split(delim);\n    const dest = [];\n    dest.push(pieces[0]);\n\n    for (let i = 1; i < pieces.length; i++) {\n      dest.push({\n        v: delim\n      }, pieces[i]);\n    }\n\n    return dest;\n  }\n\n  static _createUniquifier(desc, version, uid, sourceContext, labels) {\n    const uniquifier = desc + version + uid + JSON.stringify(sourceContext) + JSON.stringify(labels);\n    return crypto.createHash('sha1').update(uniquifier).digest('hex');\n  }\n\n}\n\nDebuglet.LEVELNAMES = ['fatal', 'error', 'warn', 'info', 'debug', 'trace'];\nexports.Debuglet = Debuglet;","map":null,"metadata":{},"sourceType":"script"}