{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2014, 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*!\n * @module debug/controller\n */\n\nconst common_1 = require(\"@google-cloud/common\");\n\nconst assert = require(\"assert\");\n\nconst qs = require(\"querystring\");\n\nconst url_1 = require(\"url\");\n\nclass Controller extends common_1.ServiceObject {\n  /**\n   * @constructor\n   */\n  constructor(debug, config) {\n    super({\n      parent: debug,\n      baseUrl: '/controller'\n    });\n    /** @private {string} */\n\n    this.nextWaitToken = null;\n    this.apiUrl = \"https://\".concat(debug.apiEndpoint, \"/v2/controller\");\n\n    if (config && config.apiUrl) {\n      this.apiUrl = config.apiUrl + new url_1.URL(this.apiUrl).pathname;\n    }\n  }\n  /**\n   * Register to the API (implementation)\n   *\n   * @param {!function(?Error,Object=)} callback\n   * @private\n   */\n\n\n  register(debuggee, callback) {\n    const options = {\n      uri: this.apiUrl + '/debuggees/register',\n      method: 'POST',\n      json: true,\n      body: {\n        debuggee\n      }\n    };\n    this.request(options, (err, body, response) => {\n      if (err) {\n        callback(err);\n      } else if (response.statusCode !== 200) {\n        callback(new Error('unable to register, statusCode ' + response.statusCode));\n      } else if (!body.debuggee) {\n        callback(new Error('invalid response body from server'));\n      } else {\n        debuggee.id = body.debuggee.id;\n        callback(null, body);\n      }\n    });\n  }\n  /**\n   * Fetch the list of breakpoints from the server. Assumes we have registered.\n   * @param {!function(?Error,Object=,Object=)} callback accepting (err, response,\n   * body)\n   */\n\n\n  listBreakpoints(debuggee, callback) {\n    const that = this;\n    assert(debuggee.id, 'should have a registered debuggee');\n    const query = {\n      successOnTimeout: true\n    };\n\n    if (that.nextWaitToken) {\n      query.waitToken = that.nextWaitToken;\n    }\n\n    const uri = this.apiUrl + '/debuggees/' + encodeURIComponent(debuggee.id) + '/breakpoints?' + qs.stringify(query);\n    that.request({\n      uri,\n      json: true\n    }, (err, body, response) => {\n      if (!response) {\n        callback(err || new Error('unknown error - request response missing'));\n        return;\n      } else if (response.statusCode === 404) {\n        // The v2 API returns 404 (google.rpc.Code.NOT_FOUND) when the agent\n        // registration expires. We should re-register.\n        callback(null, response);\n        return;\n      } else if (response.statusCode !== 200) {\n        callback(new Error('unable to list breakpoints, status code ' + response.statusCode));\n        return;\n      } else {\n        body = body || {};\n        that.nextWaitToken = body.nextWaitToken;\n        callback(null, response, body);\n      }\n    });\n  }\n  /**\n   * Update the server about breakpoint state\n   * @param {!Debuggee} debuggee\n   * @param {!Breakpoint} breakpoint\n   * @param {!Function} callback accepting (err, body)\n   */\n\n\n  updateBreakpoint(debuggee, breakpoint, callback) {\n    assert(debuggee.id, 'should have a registered debuggee');\n    breakpoint.action = 'CAPTURE';\n    breakpoint.isFinalState = true;\n    const options = {\n      uri: this.apiUrl + '/debuggees/' + encodeURIComponent(debuggee.id) + // TODO: Address the case where `breakpoint.id` is `undefined`.\n      '/breakpoints/' + encodeURIComponent(breakpoint.id),\n      json: true,\n      method: 'PUT',\n      body: {\n        debuggeeId: debuggee.id,\n        breakpoint\n      }\n    }; // We need to have a try/catch here because a JSON.stringify will be done\n    // by request. Some V8 debug mirror objects get a throw when we attempt to\n    // stringify them. The try-catch keeps it resilient and avoids crashing the\n    // user's app.\n\n    try {\n      this.request(options, (err, body\n      /*, response */\n      ) => {\n        callback(err, body);\n      });\n    } catch (error) {\n      callback(error);\n    }\n  }\n\n}\n\nexports.Controller = Controller;","map":null,"metadata":{},"sourceType":"script"}