{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst fs = require(\"fs\");\n\nconst p_limit_1 = require(\"p-limit\");\n\nconst path = require(\"path\");\n\nconst util_1 = require(\"util\");\n\nconst sourceMap = require(\"source-map\");\n\nconst utils_1 = require(\"../util/utils\");\n\nconst CONCURRENCY = 10;\nconst WEBPACK_PREFIX = 'webpack://';\nconst readFilep = util_1.promisify(fs.readFile);\n/** @define {string} */\n\nconst MAP_EXT = '.map';\n/**\n * @param {!Map} infoMap The map that maps input source files to\n *  SourceMapConsumer objects that are used to calculate mapping information\n * @param {string} mapPath The path to the sourcemap file to process.  The\n *  path should be relative to the process's current working directory\n * @private\n */\n\nasync function processSourcemap(infoMap, mapPath) {\n  // this handles the case when the path is undefined, null, or\n  // the empty string\n  if (!mapPath || !mapPath.endsWith(MAP_EXT)) {\n    throw new Error(\"The path \".concat(mapPath, \" does not specify a sourcemap file\"));\n  }\n\n  mapPath = path.normalize(mapPath);\n  let contents;\n\n  try {\n    contents = await readFilep(mapPath, 'utf8');\n  } catch (e) {\n    throw new Error('Could not read sourcemap file ' + mapPath + ': ' + e);\n  }\n\n  let consumer;\n\n  try {\n    // TODO: Determine how to reconsile the type conflict where `consumer`\n    //       is constructed as a SourceMapConsumer but is used as a\n    //       RawSourceMap.\n    // TODO: Resolve the cast of `contents as any` (This is needed because the\n    //       type is expected to be of `RawSourceMap` but the existing\n    //       working code uses a string.)\n    consumer = new sourceMap.SourceMapConsumer(contents);\n  } catch (e) {\n    throw new Error('An error occurred while reading the ' + 'sourcemap file ' + mapPath + ': ' + e);\n  }\n  /*\n   * If the sourcemap file defines a \"file\" attribute, use it as\n   * the output file where the path is relative to the directory\n   * containing the map file.  Otherwise, use the name of the output\n   * file (with the .map extension removed) as the output file.\n   */\n\n\n  const outputBase = consumer.file ? consumer.file : path.basename(mapPath, '.map');\n  const parentDir = path.dirname(mapPath);\n  const outputPath = path.normalize(path.join(parentDir, outputBase)); // the sources are in ascending order from shortest to longest\n\n  const nonemptySources = consumer.sources.filter(val => !!val).sort((src1, src2) => src1.length - src2.length);\n  const normalizedSources = nonemptySources.map(src => {\n    if (src.toLowerCase().startsWith(WEBPACK_PREFIX)) {\n      return src.substring(WEBPACK_PREFIX.length);\n    }\n\n    return src;\n  }).map(relPath => {\n    // resolve the paths relative to the map file so that\n    // they are relative to the process's current working\n    // directory\n    return path.normalize(path.join(parentDir, relPath));\n  });\n\n  if (normalizedSources.length === 0) {\n    throw new Error('No sources listed in the sourcemap file ' + mapPath);\n  }\n\n  for (const src of normalizedSources) {\n    infoMap.set(path.normalize(src), {\n      outputFile: outputPath,\n      mapFile: mapPath,\n      mapConsumer: consumer,\n      sources: nonemptySources\n    });\n  }\n}\n\nclass SourceMapper {\n  /**\n   * @param {Array.<string>} sourcemapPaths An array of paths to .map sourcemap\n   *  files that should be processed.  The paths should be relative to the\n   *  current process's current working directory\n   * @param {Logger} logger A logger that reports errors that occurred while\n   *  processing the given sourcemap files\n   * @constructor\n   */\n  constructor() {\n    this.infoMap = new Map();\n  }\n  /**\n   * Used to get the information about the transpiled file from a given input\n   * source file provided there isn't any ambiguity with associating the input\n   * path to exactly one output transpiled file.\n   *\n   * @param inputPath The (possibly relative) path to the original source file.\n   * @return The `MapInfoInput` object that describes the transpiled file\n   *  associated with the specified input path.  `null` is returned if either\n   *  zero files are associated with the input path or if more than one file\n   *  could possibly be associated with the given input path.\n   */\n\n\n  getMappingInfo(inputPath) {\n    if (this.infoMap.has(path.normalize(inputPath))) {\n      return this.infoMap.get(inputPath);\n    }\n\n    const matches = utils_1.findScriptsFuzzy(inputPath, Array.from(this.infoMap.keys()));\n\n    if (matches.length === 1) {\n      return this.infoMap.get(matches[0]);\n    }\n\n    return null;\n  }\n  /**\n   * Used to determine if the source file specified by the given path has\n   * a .map file and an output file associated with it.\n   *\n   * If there is no such mapping, it could be because the input file is not\n   * the input to a transpilation process or it is the input to a transpilation\n   * process but its corresponding .map file was not given to the constructor\n   * of this mapper.\n   *\n   * @param {string} inputPath The path to an input file that could\n   *  possibly be the input to a transpilation process.  The path should be\n   *  relative to the process's current working directory.\n   */\n\n\n  hasMappingInfo(inputPath) {\n    return this.getMappingInfo(inputPath) !== null;\n  }\n  /**\n   * @param {string} inputPath The path to an input file that could possibly\n   *  be the input to a transpilation process.  The path should be relative to\n   *  the process's current working directory\n   * @param {number} The line number in the input file where the line number is\n   *   zero-based.\n   * @param {number} (Optional) The column number in the line of the file\n   *   specified where the column number is zero-based.\n   * @return {Object} The object returned has a \"file\" attribute for the\n   *   path of the output file associated with the given input file (where the\n   *   path is relative to the process's current working directory),\n   *   a \"line\" attribute of the line number in the output file associated with\n   *   the given line number for the input file, and an optional \"column\" number\n   *   of the column number of the output file associated with the given file\n   *   and line information.\n   *\n   *   If the given input file does not have mapping information associated\n   *   with it then null is returned.\n   */\n\n\n  mappingInfo(inputPath, lineNumber, colNumber) {\n    inputPath = path.normalize(inputPath);\n    const entry = this.getMappingInfo(inputPath);\n\n    if (entry === null) {\n      return null;\n    }\n\n    const relPath = path.relative(path.dirname(entry.mapFile), inputPath).replace(/\\\\/g, '/');\n    /**\n     * Note: Since `entry.sources` is in ascending order from shortest\n     *       to longest, the first source path that ends with the\n     *       relative path is necessarily the shortest source path\n     *       that ends with the relative path.\n     */\n\n    let source;\n\n    for (const src of entry.sources) {\n      if (src.endsWith(relPath)) {\n        source = src;\n        break;\n      }\n    }\n\n    const sourcePos = {\n      source: source || relPath,\n      line: lineNumber + 1,\n      // to be one-based but expects the column number\n      column: colNumber\n    }; // TODO: Determine how to remove the explicit cast here.\n\n    const consumer = entry.mapConsumer;\n    const allPos = consumer.allGeneratedPositionsFor(sourcePos);\n    /*\n     * Based on testing, it appears that the following code is needed to\n     * properly get the correct mapping information.\n     *\n     * In particular, the generatedPositionFor() alone doesn't appear to\n     * give the correct mapping information.\n     */\n\n    const mappedPos = allPos && allPos.length > 0 ? allPos.reduce((accumulator, value) => {\n      return value.line < accumulator.line ? value : accumulator;\n    }) : consumer.generatedPositionFor(sourcePos);\n    return {\n      file: entry.outputFile,\n      line: mappedPos.line - 1,\n      // by the SourceMapConsumer to the expected\n      // zero-based output.\n      // TODO: The `sourceMap.Position` type definition has a `column`\n      //       attribute and not a `col` attribute.  Determine if the type\n      //       definition or this code is correct.\n      column: mappedPos.col\n    };\n  }\n\n}\n\nexports.SourceMapper = SourceMapper;\n\nasync function create(sourcemapPaths) {\n  const limit = p_limit_1.default(CONCURRENCY);\n  const mapper = new SourceMapper();\n  const promises = sourcemapPaths.map(path => limit(() => processSourcemap(mapper.infoMap, path)));\n\n  try {\n    await Promise.all(promises);\n  } catch (err) {\n    throw new Error('An error occurred while processing the sourcemap files' + err);\n  }\n\n  return mapper;\n}\n\nexports.create = create;","map":null,"metadata":{},"sourceType":"script"}