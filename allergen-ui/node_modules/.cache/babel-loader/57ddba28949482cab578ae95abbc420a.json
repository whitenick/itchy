{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst acorn = require(\"acorn\");\n\nconst path = require(\"path\");\n\nconst semver = require(\"semver\");\n\nconst vm = require(\"vm\");\n\nconst status_message_1 = require(\"../../client/stackdriver/status-message\");\n\nconst state = require(\"../state/legacy-state\");\n\nconst utils = require(\"../util/utils\");\n\nconst debugapi = require(\"./debugapi\");\n\nclass V8BreakpointData {\n  constructor(apiBreakpoint, v8Breakpoint, parsedCondition, // TODO: The code in this method assumes that `compile` exists.  Verify\n  // that is correct.\n  // TODO: Update this so that `null|` is not needed for `compile`.\n  compile) {\n    this.apiBreakpoint = apiBreakpoint;\n    this.v8Breakpoint = v8Breakpoint;\n    this.parsedCondition = parsedCondition;\n    this.compile = compile;\n  }\n\n}\n\nexports.V8BreakpointData = V8BreakpointData;\n\nclass V8DebugApi {\n  constructor(logger, config, jsFiles, sourcemapper) {\n    this.breakpoints = {};\n    this.listeners = {};\n    this.numBreakpoints = 0;\n    this.sourcemapper = sourcemapper; // This constructor is only used in situations where the legacy vm\n    // interface is used that has the `runInDebugContext` method.\n\n    this.v8 = vm.runInDebugContext('Debug');\n    this.config = config;\n    this.fileStats = jsFiles;\n    this.v8Version = /(\\d+\\.\\d+\\.\\d+)\\.\\d+/.exec(process.versions.v8);\n    this.logger = logger;\n    this.usePermanentListener = semver.satisfies(this.v8Version[1], '>=4.5');\n\n    this.handleDebugEvents = (evt, execState, eventData) => {\n      try {\n        switch (evt) {\n          // TODO: Address the case where `v8` is `null`.\n          case this.v8.DebugEvent.Break:\n            eventData.breakPointsHit().forEach(hit => {\n              const num = hit.script_break_point().number();\n\n              if (this.listeners[num].enabled) {\n                this.logger.info('>>>V8 breakpoint hit<<< number: ' + num);\n                this.listeners[num].listener(execState, eventData);\n              }\n            });\n            break;\n\n          default:\n        }\n      } catch (e) {\n        this.logger.warn('Internal V8 error on breakpoint event: ' + e);\n      }\n    };\n\n    if (this.usePermanentListener) {\n      this.logger.info('activating v8 breakpoint listener (permanent)');\n      this.v8.setListener(this.handleDebugEvents);\n    }\n  }\n\n  set(breakpoint, cb) {\n    if (!this.v8 || !breakpoint || typeof breakpoint.id === 'undefined' || // 0 is a valid id\n    !breakpoint.location || !breakpoint.location.path || !breakpoint.location.line) {\n      return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.UNSPECIFIED, utils.messages.INVALID_BREAKPOINT);\n    }\n\n    const baseScriptPath = path.normalize(breakpoint.location.path);\n\n    if (!this.sourcemapper.hasMappingInfo(baseScriptPath)) {\n      if (!baseScriptPath.endsWith('.js')) {\n        return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_SOURCE_LOCATION, utils.messages.COULD_NOT_FIND_OUTPUT_FILE);\n      }\n\n      this.setInternal(breakpoint, null\n      /* mapInfo */\n      , null\n      /* compile */\n      , cb);\n    } else {\n      const line = breakpoint.location.line;\n      const column = 0;\n      const mapInfo = this.sourcemapper.mappingInfo(baseScriptPath, line, column);\n      const compile = utils.getBreakpointCompiler(breakpoint);\n\n      if (breakpoint.condition && compile) {\n        try {\n          breakpoint.condition = compile(breakpoint.condition);\n        } catch (e) {\n          this.logger.info('Unable to compile condition >> ' + breakpoint.condition + ' <<');\n          return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_CONDITION, utils.messages.ERROR_COMPILING_CONDITION);\n        }\n      }\n\n      this.setInternal(breakpoint, mapInfo, compile, cb);\n    }\n  }\n\n  clear(breakpoint, cb) {\n    if (typeof breakpoint.id === 'undefined') {\n      return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_CONDITION, utils.messages.V8_BREAKPOINT_CLEAR_ERROR);\n    }\n\n    const breakpointData = this.breakpoints[breakpoint.id];\n\n    if (!breakpointData) {\n      return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_CONDITION, utils.messages.V8_BREAKPOINT_CLEAR_ERROR);\n    }\n\n    const v8bp = breakpointData.v8Breakpoint;\n    this.v8.clearBreakPoint(v8bp.number());\n    delete this.breakpoints[breakpoint.id];\n    delete this.listeners[v8bp.number()];\n    this.numBreakpoints--;\n\n    if (this.numBreakpoints === 0 && !this.usePermanentListener) {\n      // removed last breakpoint\n      this.logger.info('deactivating v8 breakpoint listener');\n      this.v8.setListener(null);\n    }\n\n    setImmediate(() => {\n      cb(null);\n    });\n  }\n\n  wait(breakpoint, callback) {\n    const that = this;\n    const num = that.breakpoints[breakpoint.id].v8Breakpoint.number();\n    const listener = this.onBreakpointHit.bind(this, breakpoint, err => {\n      that.listeners[num].enabled = false; // This method is called from the debug event listener, which\n      // swallows all exception. We defer the callback to make sure the\n      // user errors aren't silenced.\n\n      setImmediate(() => {\n        callback(err || undefined);\n      });\n    });\n    that.listeners[num] = {\n      enabled: true,\n      listener\n    };\n  }\n\n  log(breakpoint, print, shouldStop) {\n    const that = this;\n    const num = that.breakpoints[breakpoint.id].v8Breakpoint.number();\n    let logsThisSecond = 0;\n    let timesliceEnd = Date.now() + 1000; // TODO: Determine why the Error argument is not used.\n\n    const listener = this.onBreakpointHit.bind(this, breakpoint, err => {\n      const currTime = Date.now();\n\n      if (currTime > timesliceEnd) {\n        logsThisSecond = 0;\n        timesliceEnd = currTime + 1000;\n      }\n\n      print( // TODO: Address the case where `breakpoint.logMessageFormat` is\n      // null\n      breakpoint.logMessageFormat, breakpoint.evaluatedExpressions.map(obj => JSON.stringify(obj)));\n      logsThisSecond++;\n\n      if (shouldStop()) {\n        that.listeners[num].enabled = false;\n      } else {\n        if (logsThisSecond >= that.config.log.maxLogsPerSecond) {\n          that.listeners[num].enabled = false;\n          setTimeout(() => {\n            // listeners[num] may have been deleted by `clear` during the\n            // async hop. Make sure it is valid before setting a property\n            // on it.\n            if (!shouldStop() && that.listeners[num]) {\n              that.listeners[num].enabled = true;\n            }\n          }, that.config.log.logDelaySeconds * 1000);\n        }\n      }\n    });\n    that.listeners[num] = {\n      enabled: true,\n      listener\n    };\n  }\n\n  disconnect() {\n    return;\n  }\n\n  numBreakpoints_() {\n    return Object.keys(this.breakpoints).length;\n  }\n\n  numListeners_() {\n    return Object.keys(this.listeners).length;\n  }\n\n  setInternal(breakpoint, mapInfo, compile, cb) {\n    // Parse and validate conditions and watch expressions for correctness and\n    // immutability\n    let ast = null;\n\n    if (breakpoint.condition) {\n      try {\n        // We parse as ES6; even though the underlying V8 version may only\n        // support a subset. This should be fine as the objective of the parse\n        // is to heuristically find side-effects. V8 will raise errors later\n        // if the syntax is invalid. It would have been nice if V8 had made the\n        // parser API available us :(.\n        ast = acorn.parse(breakpoint.condition, {\n          sourceType: 'script',\n          ecmaVersion: 6\n        });\n\n        const validator = require('../util/validator.js');\n\n        if (!validator.isValid(ast)) {\n          return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_CONDITION, utils.messages.DISALLOWED_EXPRESSION);\n        }\n      } catch (err) {\n        return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_CONDITION, utils.messages.SYNTAX_ERROR_IN_CONDITION + err.message);\n      }\n    } // Presently it is not possible to precisely disambiguate the script\n    // path from the path provided by the debug server. The issue is that we\n    // don't know the repository root relative to the root filesystem or\n    // relative to the working-directory of the process. We want to make sure\n    // that we are setting the breakpoint that the user intended instead of a\n    // breakpoint in a file that happens to have the same name but is in a\n    // different directory. Until this is addressed between the server and the\n    // debuglet, we are going to assume that repository root === the starting\n    // working directory.\n\n\n    let matchingScript;\n    const scripts = utils.findScripts(mapInfo ? mapInfo.file : path.normalize(breakpoint.location.path), this.config, this.fileStats, this.logger);\n\n    if (scripts.length === 0) {\n      return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_SOURCE_LOCATION, utils.messages.SOURCE_FILE_NOT_FOUND);\n    } else if (scripts.length === 1) {\n      // Found the script\n      matchingScript = scripts[0];\n    } else {\n      return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_SOURCE_LOCATION, utils.messages.SOURCE_FILE_AMBIGUOUS);\n    } // The breakpoint protobuf message presently doesn't have a column property\n    // but it may have one in the future.\n    // TODO: Address the case where `breakpoint.location` is `null`.\n\n\n    let column = mapInfo && mapInfo.column ? mapInfo.column : breakpoint.location.column || 1;\n    const line = mapInfo ? mapInfo.line : breakpoint.location.line; // We need to special case breakpoints on the first line. Since Node.js\n    // wraps modules with a function expression, we adjust\n    // to deal with that.\n\n    if (line === 1) {\n      column += debugapi.MODULE_WRAP_PREFIX_LENGTH - 1;\n    } // TODO: Address the case where `fileStats[matchingScript]` is `null`.\n\n\n    if (line >= this.fileStats[matchingScript].lines) {\n      return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_SOURCE_LOCATION, utils.messages.INVALID_LINE_NUMBER + matchingScript + ':' + line + '. Loaded script contained ' + this.fileStats[matchingScript].lines + ' lines. Please ensure' + ' that the snapshot was set in the same code version as the' + ' deployed source.');\n    }\n\n    const v8bp = this.setByRegExp(matchingScript, line, column);\n\n    if (!v8bp) {\n      return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_SOURCE_LOCATION, utils.messages.V8_BREAKPOINT_ERROR);\n    }\n\n    if (this.numBreakpoints === 0 && !this.usePermanentListener) {\n      // added first breakpoint\n      this.logger.info('activating v8 breakpoint listener');\n      this.v8.setListener(this.handleDebugEvents);\n    }\n\n    this.breakpoints[breakpoint.id] = // TODO: Address the case where `ast` is `null`.\n    new V8BreakpointData(breakpoint, v8bp, ast, compile);\n    this.numBreakpoints++;\n    setImmediate(() => {\n      cb(null);\n    }); // success.\n  }\n\n  setByRegExp(scriptPath, line, column) {\n    const regexp = utils.pathToRegExp(scriptPath);\n    const num = this.v8.setScriptBreakPointByRegExp(regexp, line - 1, column - 1);\n    const v8bp = this.v8.findBreakPoint(num);\n    return v8bp;\n  }\n\n  onBreakpointHit(breakpoint, callback, execState) {\n    // TODO: Address the situation where `breakpoint.id` is `null`.\n    const v8bp = this.breakpoints[breakpoint.id].v8Breakpoint;\n\n    if (!v8bp.active()) {\n      // Breakpoint exists, but not active. We never disable breakpoints, so\n      // this is theoretically not possible. Perhaps this is possible if there\n      // is a second debugger present? Regardless, report the error.\n      return utils.setErrorStatusAndCallback(callback, breakpoint, status_message_1.StatusMessage.BREAKPOINT_SOURCE_LOCATION, utils.messages.V8_BREAKPOINT_DISABLED);\n    }\n\n    const result = this.checkCondition(breakpoint, execState);\n\n    if (result.error) {\n      return utils.setErrorStatusAndCallback(callback, breakpoint, status_message_1.StatusMessage.BREAKPOINT_CONDITION, utils.messages.ERROR_EVALUATING_CONDITION + result.error);\n    } else if (!result.value) {\n      // Check again next time\n      this.logger.info(\"\\tthe breakpoint condition wasn't met\");\n      return;\n    } // Breakpoint Hit\n\n\n    const start = process.hrtime();\n\n    try {\n      this.captureBreakpointData(breakpoint, execState);\n    } catch (err) {\n      return utils.setErrorStatusAndCallback(callback, breakpoint, status_message_1.StatusMessage.BREAKPOINT_SOURCE_LOCATION, utils.messages.CAPTURE_BREAKPOINT_DATA + err);\n    }\n\n    const end = process.hrtime(start);\n    this.logger.info(utils.formatInterval('capture time: ', end));\n    callback(null);\n  }\n  /**\n   * Evaluates the breakpoint condition, if present.\n   * @return object with either a boolean value or an error property\n   */\n\n\n  checkCondition(breakpoint, execState) {\n    if (!breakpoint.condition) {\n      return {\n        value: true\n      };\n    }\n\n    const result = state.evaluate(breakpoint.condition, execState.frame(0));\n\n    if (result.error) {\n      return {\n        error: result.error\n      };\n    } // TODO: Address the case where `result.mirror` is `null`.\n\n\n    return {\n      value: !!result.mirror.value()\n    }; // intentional !!\n  }\n\n  captureBreakpointData(breakpoint, execState) {\n    const expressionErrors = [];\n\n    if (breakpoint.expressions && this.breakpoints[breakpoint.id].compile) {\n      for (let i = 0; i < breakpoint.expressions.length; i++) {\n        try {\n          breakpoint.expressions[i] = // TODO: Address the case where `compile` is `null`.\n          this.breakpoints[breakpoint.id].compile(breakpoint.expressions[i]);\n        } catch (e) {\n          this.logger.info('Unable to compile watch expression >> ' + breakpoint.expressions[i] + ' <<');\n          expressionErrors.push({\n            name: breakpoint.expressions[i],\n            status: new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, 'Error Compiling Expression', true)\n          });\n          breakpoint.expressions.splice(i, 1);\n          i--;\n        }\n      }\n    }\n\n    if (breakpoint.action === 'LOG') {\n      // TODO: This doesn't work with compiled languages if there is an error\n      // compiling one of the expressions in the loop above.\n      if (!breakpoint.expressions) {\n        breakpoint.evaluatedExpressions = [];\n      } else {\n        const frame = execState.frame(0);\n        const evaluatedExpressions = breakpoint.expressions.map(exp => {\n          const result = state.evaluate(exp, frame); // TODO: Address the case where `result.mirror` is `undefined`.\n\n          return result.error ? result.error : result.mirror.value();\n        });\n        breakpoint.evaluatedExpressions = evaluatedExpressions;\n      }\n    } else {\n      // TODO: Address the case where `breakpoint.expression` is `undefined`.\n      const captured = state.capture(execState, breakpoint.expressions, this.config, this.v8);\n\n      if (breakpoint.location && utils.isJavaScriptFile(breakpoint.location.path) && captured.location && captured.location.line) {\n        breakpoint.location.line = captured.location.line;\n      }\n\n      breakpoint.stackFrames = captured.stackFrames; // TODO: This suggests the Status type and Variable type are the same.\n      //       Determine if that is the case.\n\n      breakpoint.variableTable = captured.variableTable;\n      breakpoint.evaluatedExpressions = expressionErrors.concat(captured.evaluatedExpressions);\n    }\n  }\n\n}\n\nexports.V8DebugApi = V8DebugApi;","map":null,"metadata":{},"sourceType":"script"}