{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst is_1 = require(\"@sindresorhus/is\");\n\nconst path = require(\"path\");\n\nconst semver = require(\"semver\");\n\nconst status_message_1 = require(\"../../client/stackdriver/status-message\");\n\nexports.messages = {\n  INVALID_BREAKPOINT: 'invalid snapshot - id or location missing',\n  SOURCE_FILE_NOT_FOUND: 'A script matching the source file was not found loaded on the debuggee',\n  SOURCE_FILE_AMBIGUOUS: 'Multiple files match the path specified',\n  V8_BREAKPOINT_ERROR: 'Unable to set breakpoint in v8',\n  V8_BREAKPOINT_CLEAR_ERROR: 'Unable to clear breakpoint in v8',\n  SYNTAX_ERROR_IN_CONDITION: 'Syntax error in condition: ',\n  ERROR_EVALUATING_CONDITION: 'Error evaluating condition: ',\n  ERROR_COMPILING_CONDITION: 'Error compiling condition.',\n  DISALLOWED_EXPRESSION: 'Expression not allowed',\n  SOURCE_MAP_READ_ERROR: 'The source map could not be read or was incorrectly formatted',\n  V8_BREAKPOINT_DISABLED: 'Internal error: V8 breakpoint externally disabled',\n  CAPTURE_BREAKPOINT_DATA: 'Error trying to capture snapshot data: ',\n  INVALID_LINE_NUMBER: 'Invalid snapshot position: ',\n  COULD_NOT_FIND_OUTPUT_FILE: 'Could not determine the output file associated with the transpiled input file'\n}; // Exposed for unit testing.\n\nfunction findScripts(scriptPath, config, fileStats, logger) {\n  // (path: string, knownFiles: string[], resolved: string[]) => string[]\n  const resolved = resolveScripts(scriptPath, config, fileStats);\n\n  if (config.pathResolver) {\n    if (!is_1.default.function_(config.pathResolver)) {\n      logger.warn(\"The 'pathResolver' config must be a function.  Continuing \" + \"with the agent's default behavior.\");\n      return resolved;\n    }\n\n    const knownFiles = Object.keys(fileStats);\n    const calculatedPaths = config.pathResolver(scriptPath, knownFiles, resolved);\n\n    if (calculatedPaths === undefined) {\n      return resolved;\n    }\n\n    if (!calculatedPaths || !Array.isArray(calculatedPaths)) {\n      logger.warn(\"The 'pathResolver' config function returned a value \" + \"other than 'undefined' or an array of strings. Continuing with \" + \"the agent's default behavior.\");\n      return resolved;\n    }\n\n    for (const path of calculatedPaths) {\n      if (knownFiles.indexOf(path) === -1) {\n        logger.warn(\"The 'pathResolver' config function returned a path \" + \"'\".concat(path, \"' that is not in the list of paths known to the debug agent \") + JSON.stringify(knownFiles, null, 2) + \" only known paths can be returned. Continuing with the agent's \" + \"default behavior.\");\n        return resolved;\n      }\n    }\n\n    return calculatedPaths;\n  }\n\n  return resolved;\n}\n\nexports.findScripts = findScripts;\n\nfunction resolveScripts(scriptPath, config, fileStats) {\n  // Use repository relative mapping if present.\n  if (config.appPathRelativeToRepository) {\n    const candidate = scriptPath.replace(config.appPathRelativeToRepository, config.workingDirectory); // There should be no ambiguity resolution if project root is provided.\n\n    return fileStats[candidate] ? [candidate] : [];\n  }\n\n  const regexp = pathToRegExp(scriptPath); // Next try to match path.\n\n  const matches = Object.keys(fileStats).filter(regexp.test.bind(regexp));\n\n  if (matches.length === 1) {\n    return matches;\n  } // Finally look for files with the same name regardless of path.\n\n\n  return findScriptsFuzzy(scriptPath, Object.keys(fileStats));\n}\n/**\n * Given an list of available files and a script path to match, this function\n * tries to resolve the script to a (hopefully unique) match in the file list\n * disregarding the full path to the script. This can be useful because repo\n * file paths (that the UI has) may not necessarily be suffixes of the absolute\n * paths of the deployed files. This happens when the user deploys a\n * subdirectory of the repo.\n *\n * For example consider a file named `a/b.js` in the repo. If the\n * directory contents of `a` are deployed rather than the whole repo, we are not\n * going to have any file named `a/b.js` in the running Node process.\n *\n * We incrementally consider more components of the path until we find a unique\n * match, or return all the potential matches.\n *\n * @example findScriptsFuzzy('a/b.js', ['/d/b.js']) // -> ['/d/b.js']\n * @example findScriptsFuzzy('a/b.js', ['/c/b.js', '/d/b.js']); // -> []\n * @example findScriptsFuzzy('a/b.js', ['/x/a/b.js', '/y/a/b.js'])\n *                 // -> ['x/a/b.js', 'y/a/b.js']\n *\n * @param {string} scriptPath partial path to the script.\n * @param {array<string>} fileList an array of absolute paths of filenames\n *     available.\n * @return {array<string>} list of files that match.\n */\n\n\nfunction findScriptsFuzzy(scriptPath, fileList) {\n  let matches = fileList;\n  const components = scriptPath.split(path.sep);\n\n  for (let i = components.length - 1; i >= 0; i--) {\n    const regexp = pathToRegExp(components.slice(i).join(path.sep));\n    matches = matches.filter(regexp.test.bind(regexp));\n\n    if (matches.length <= 1) {\n      break; // Either no matches, or we found a unique match.\n    }\n  }\n\n  return matches;\n}\n\nexports.findScriptsFuzzy = findScriptsFuzzy;\n/**\n * @param {!string} scriptPath path of a script\n */\n\nfunction pathToRegExp(scriptPath) {\n  // make sure the script path starts with a slash. This makes sure our\n  // regexp doesn't match monkey.js when the user asks to set a breakpoint\n  // in key.js\n  if (path.sep === '/' || scriptPath.indexOf(':') === -1) {\n    scriptPath = path.join(path.sep, scriptPath);\n  }\n\n  if (path.sep !== '/') {\n    scriptPath = scriptPath.replace(new RegExp('\\\\\\\\', 'g'), '\\\\\\\\');\n  } // Escape '.' characters.\n\n\n  scriptPath = scriptPath.replace('.', '\\\\.');\n  return new RegExp(scriptPath + '$');\n}\n\nexports.pathToRegExp = pathToRegExp;\n/**\n * Formats a provided message and a high-resolution interval of the format\n * [seconds, nanoseconds] (for example, from process.hrtime()) prefixed with a\n * provided message as a string intended for logging.\n * @param {string} msg The mesage that prefixes the formatted interval.\n * @param {number[]} interval The interval to format.\n * @return {string} A formatted string.\n */\n\nexports.formatInterval = (msg, interval) => {\n  return msg + (interval[0] * 1000 + interval[1] / 1000000) + 'ms';\n};\n\nfunction setErrorStatusAndCallback(fn, breakpoint, refersTo, message) {\n  const error = new Error(message);\n  setImmediate(() => {\n    if (breakpoint && !breakpoint.status) {\n      breakpoint.status = new status_message_1.StatusMessage(refersTo, message, true);\n    }\n\n    fn(error);\n  });\n}\n\nexports.setErrorStatusAndCallback = setErrorStatusAndCallback;\n/**\n * Produces a compilation function based on the file extension of the\n * script path in which the breakpoint is set.\n *\n * @param {Breakpoint} breakpoint\n */\n\nfunction getBreakpointCompiler(breakpoint) {\n  // TODO: Address the case where `breakpoint.location` is `null`.\n  switch (path.normalize(breakpoint.location.path).split('.').pop()) {\n    case 'coffee':\n      return uncompiled => {\n        const comp = require('coffeescript');\n\n        const compiled = comp.compile('0 || (' + uncompiled + ')'); // Strip out coffeescript scoping wrapper to get translated condition\n\n        const re = /\\(function\\(\\) {\\s*0 \\|\\| \\((.*)\\);\\n\\n\\}\\)\\.call\\(this\\);/;\n        const match = re.exec(compiled);\n\n        if (match && match.length > 1) {\n          return match[1].trim();\n        } else {\n          throw new Error('Compilation Error for: ' + uncompiled);\n        }\n      };\n\n    case 'es6':\n    case 'es':\n    case 'jsx':\n      return uncompiled => {\n        // If we want to support es6 watch expressions we can compile them\n        // here. Babel is a large dependency to have if we don't need it in\n        // all cases.\n        return uncompiled;\n      };\n\n    default:\n      return null;\n  }\n}\n\nexports.getBreakpointCompiler = getBreakpointCompiler;\n\nfunction removeFirstOccurrenceInArray(array, element) {\n  const index = array.indexOf(element);\n\n  if (index >= 0) {\n    array.splice(index, 1);\n  }\n}\n\nexports.removeFirstOccurrenceInArray = removeFirstOccurrenceInArray;\n/**\n * Used to determine whether the specified node version satisfies the\n * given semver range.  This method is able to properly handle nightly\n * builds.  For example,\n *    satisfies('v10.0.0-nightly201804132a6ab9b37b', '>=10')\n * returns `true`.\n *\n * @param version The node version.\n * @param semverRange The semver range to check against\n */\n\nfunction satisfies(nodeVersion, semverRange) {\n  // Coercing the version is needed to handle nightly builds correctly.\n  // In particular,\n  //   semver.satisfies('v10.0.0-nightly201804132a6ab9b37b', '>=10')\n  // returns `false`.\n  //\n  // `semver.coerce` can be used to coerce that nightly version to v10.0.0.\n  const coercedVersion = semver.coerce(nodeVersion);\n  const finalVersion = coercedVersion ? coercedVersion.version : nodeVersion;\n  return semver.satisfies(finalVersion, semverRange);\n}\n\nexports.satisfies = satisfies;\n/**\n * Used to determine if the specified file is a JavaScript file\n * by determining if it has a `.js` file extension.\n *\n * @param filepath The path of the file to analyze.\n */\n\nfunction isJavaScriptFile(filepath) {\n  return path.extname(filepath).toLowerCase() === '.js';\n}\n\nexports.isJavaScriptFile = isJavaScriptFile;","map":null,"metadata":{},"sourceType":"script"}