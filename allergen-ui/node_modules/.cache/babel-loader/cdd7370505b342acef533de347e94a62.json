{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2018 Google LLC\n *\n * Distributed under MIT license.\n * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst gaxios_1 = require(\"gaxios\");\n\nconst jsonBigint = require('json-bigint');\n\nexports.HOST_ADDRESS = 'http://metadata.google.internal.';\nexports.BASE_PATH = '/computeMetadata/v1';\nexports.BASE_URL = exports.HOST_ADDRESS + exports.BASE_PATH;\nexports.HEADER_NAME = 'Metadata-Flavor';\nexports.HEADER_VALUE = 'Google';\nexports.HEADERS = Object.freeze({\n  [exports.HEADER_NAME]: exports.HEADER_VALUE\n}); // Accepts an options object passed from the user to the API. In previous\n// versions of the API, it referred to a `Request` or an `Axios` request\n// options object.  Now it refers to an object with very limited property\n// names. This is here to help ensure users don't pass invalid options when\n// they  upgrade from 0.4 to 0.5 to 0.8.\n\nfunction validate(options) {\n  Object.keys(options).forEach(key => {\n    switch (key) {\n      case 'params':\n      case 'property':\n      case 'headers':\n        break;\n\n      case 'qs':\n        throw new Error(\"'qs' is not a valid configuration option. Please use 'params' instead.\");\n\n      default:\n        throw new Error(\"'\".concat(key, \"' is not a valid configuration option.\"));\n    }\n  });\n}\n\nasync function metadataAccessor(type, options, noResponseRetries = 3) {\n  options = options || {};\n\n  if (typeof options === 'string') {\n    options = {\n      property: options\n    };\n  }\n\n  let property = '';\n\n  if (typeof options === 'object' && options.property) {\n    property = '/' + options.property;\n  }\n\n  validate(options);\n\n  try {\n    const res = await gaxios_1.request({\n      url: \"\".concat(exports.BASE_URL, \"/\").concat(type).concat(property),\n      headers: Object.assign({}, exports.HEADERS, options.headers),\n      retryConfig: {\n        noResponseRetries\n      },\n      params: options.params,\n      responseType: 'text'\n    }); // NOTE: node.js converts all incoming headers to lower case.\n\n    if (res.headers[exports.HEADER_NAME.toLowerCase()] !== exports.HEADER_VALUE) {\n      throw new Error(\"Invalid response from metadata service: incorrect \".concat(exports.HEADER_NAME, \" header.\"));\n    } else if (!res.data) {\n      throw new Error('Invalid response from the metadata service');\n    }\n\n    if (typeof res.data === 'string') {\n      try {\n        return jsonBigint.parse(res.data);\n      } catch (_a) {\n        /* ignore */\n      }\n    }\n\n    return res.data;\n  } catch (e) {\n    if (e.response && e.response.status !== 200) {\n      e.message = \"Unsuccessful response status code. \".concat(e.message);\n    }\n\n    throw e;\n  }\n} // tslint:disable-next-line no-any\n\n\nfunction instance(options) {\n  return metadataAccessor('instance', options);\n}\n\nexports.instance = instance; // tslint:disable-next-line no-any\n\nfunction project(options) {\n  return metadataAccessor('project', options);\n}\n\nexports.project = project;\n/**\n * Determine if the metadata server is currently available.\n */\n\nasync function isAvailable() {\n  try {\n    // Attempt to read instance metadata. As configured, this will\n    // retry 3 times if there is a valid response, and fail fast\n    // if there is an ETIMEDOUT or ENOTFOUND error.\n    await metadataAccessor('instance', undefined, 0);\n    return true;\n  } catch (err) {\n    // Failure to resolve the metadata service means that it is not available.\n    if (err.code && (err.code === 'ENOTFOUND' || err.code === 'ENOENT')) {\n      return false;\n    } // Throw unexpected errors.\n\n\n    throw err;\n  }\n}\n\nexports.isAvailable = isAvailable;","map":null,"metadata":{},"sourceType":"script"}