{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst acorn = require(\"acorn\");\n\nconst inspector = require(\"inspector\");\n\nconst path = require(\"path\");\n\nconst status_message_1 = require(\"../../client/stackdriver/status-message\");\n\nconst state = require(\"../state/inspector-state\");\n\nconst utils = require(\"../util/utils\");\n\nconst debugapi = require(\"./debugapi\");\n\nconst v8inspector_1 = require(\"./v8inspector\");\n\nclass BreakpointData {\n  constructor(id, apiBreakpoint, parsedCondition, locationStr, compile) {\n    this.id = id;\n    this.apiBreakpoint = apiBreakpoint;\n    this.parsedCondition = parsedCondition;\n    this.locationStr = locationStr;\n    this.compile = compile;\n  }\n\n}\n\nexports.BreakpointData = BreakpointData;\n\nclass InspectorDebugApi {\n  constructor(logger, config, jsFiles, sourcemapper) {\n    this.breakpoints = {}; // TODO: listeners, scrpitmapper, location mapper and breakpointmapper can use\n    // Map in the future after resolving Map.prototype.get(key) returns V or\n    // undefined.\n\n    this.listeners = {}; // scriptmapper maps scriptId to actual script path.\n\n    this.scriptMapper = {}; // locationmapper maps location string to a list of stackdriver breakpoint id.\n\n    this.locationMapper = {}; // breakpointmapper maps v8/inspector breakpoint id to a list of\n    // stackdriver breakpoint id.\n\n    this.breakpointMapper = {};\n    this.numBreakpoints = 0;\n    this.logger = logger;\n    this.config = config;\n    this.fileStats = jsFiles;\n    this.sourcemapper = sourcemapper;\n    this.session = new inspector.Session();\n    this.session.connect();\n    this.session.on('Debugger.scriptParsed', script => {\n      this.scriptMapper[script.params.scriptId] = script.params;\n    });\n    this.session.post('Debugger.enable');\n    this.session.post('Debugger.setBreakpointsActive', {\n      active: true\n    });\n    this.session.on('Debugger.paused', message => {\n      try {\n        this.handleDebugPausedEvent(message.params);\n      } catch (error) {\n        this.logger.error(error);\n      }\n    });\n    this.inspectorOptions = {\n      // Well-Formatted URL is required in Node 10.11.1+.\n      useWellFormattedUrl: utils.satisfies(process.version, '>10.11.0')\n    };\n    this.v8Inspector = new v8inspector_1.V8Inspector(this.session);\n  }\n\n  set(breakpoint, cb) {\n    if (!breakpoint || typeof breakpoint.id === 'undefined' || // 0 is a valid id\n    !breakpoint.location || !breakpoint.location.path || !breakpoint.location.line) {\n      return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.UNSPECIFIED, utils.messages.INVALID_BREAKPOINT);\n    }\n\n    const baseScriptPath = path.normalize(breakpoint.location.path);\n\n    if (!this.sourcemapper.hasMappingInfo(baseScriptPath)) {\n      if (!baseScriptPath.endsWith('js')) {\n        return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_SOURCE_LOCATION, utils.messages.COULD_NOT_FIND_OUTPUT_FILE);\n      }\n\n      this.setInternal(breakpoint, null\n      /* mapInfo */\n      , null\n      /* compile */\n      , cb);\n    } else {\n      const line = breakpoint.location.line;\n      const column = 0;\n      const mapInfo = this.sourcemapper.mappingInfo(baseScriptPath, line, column);\n      const compile = utils.getBreakpointCompiler(breakpoint);\n\n      if (breakpoint.condition && compile) {\n        try {\n          breakpoint.condition = compile(breakpoint.condition);\n        } catch (e) {\n          this.logger.info('Unable to compile condition >> ' + breakpoint.condition + ' <<');\n          return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_CONDITION, utils.messages.ERROR_COMPILING_CONDITION);\n        }\n      }\n\n      this.setInternal(breakpoint, mapInfo, compile, cb);\n    }\n  }\n\n  clear(breakpoint, cb) {\n    if (typeof breakpoint.id === 'undefined') {\n      return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_CONDITION, utils.messages.V8_BREAKPOINT_CLEAR_ERROR);\n    }\n\n    const breakpointData = this.breakpoints[breakpoint.id];\n\n    if (!breakpointData) {\n      return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_CONDITION, utils.messages.V8_BREAKPOINT_CLEAR_ERROR);\n    }\n\n    const locationStr = breakpointData.locationStr;\n    const v8BreakpointId = breakpointData.id; // delete current breakpoint from locationmapper and breakpointmapper.\n\n    utils.removeFirstOccurrenceInArray(this.locationMapper[locationStr], breakpoint.id);\n\n    if (this.locationMapper[locationStr].length === 0) {\n      delete this.locationMapper[locationStr];\n    }\n\n    utils.removeFirstOccurrenceInArray(this.breakpointMapper[v8BreakpointId], breakpoint.id);\n\n    if (this.breakpointMapper[v8BreakpointId].length === 0) {\n      delete this.breakpointMapper[v8BreakpointId];\n    }\n\n    let result = {};\n\n    if (!this.breakpointMapper[breakpointData.id]) {\n      // When breakpointmapper does not countain current v8/inspector breakpoint\n      // id, we should remove this breakpoint from v8.\n      result = this.v8Inspector.removeBreakpoint(breakpointData.id);\n    }\n\n    delete this.breakpoints[breakpoint.id];\n    delete this.listeners[breakpoint.id];\n    this.numBreakpoints--;\n    setImmediate(() => {\n      if (result.error) {\n        cb(result.error);\n      }\n\n      cb(null);\n    });\n  }\n\n  wait(breakpoint, callback) {\n    // TODO: Address the case whree `breakpoint.id` is `null`.\n    const listener = this.onBreakpointHit.bind(this, breakpoint, err => {\n      this.listeners[breakpoint.id].enabled = false; // This method is called from the debug event listener, which\n      // swallows all exception. We defer the callback to make sure\n      // the user errors aren't silenced.\n\n      setImmediate(() => {\n        callback(err || undefined);\n      });\n    });\n    this.listeners[breakpoint.id] = {\n      enabled: true,\n      listener\n    };\n  }\n\n  log(breakpoint, print, shouldStop) {\n    // TODO: Address the case whree `breakpoint.id` is `null`.\n    let logsThisSecond = 0;\n    let timesliceEnd = Date.now() + 1000; // TODO: Determine why the Error argument is not used.\n\n    const listener = this.onBreakpointHit.bind(this, breakpoint, err => {\n      const currTime = Date.now();\n\n      if (currTime > timesliceEnd) {\n        logsThisSecond = 0;\n        timesliceEnd = currTime + 1000;\n      }\n\n      print( // TODO: Address the case where `breakpoint.logMessageFormat` is\n      // `null`.\n      breakpoint.logMessageFormat, breakpoint.evaluatedExpressions.map(obj => JSON.stringify(obj)));\n      logsThisSecond++;\n\n      if (shouldStop()) {\n        this.listeners[breakpoint.id].enabled = false;\n      } else {\n        if (logsThisSecond >= this.config.log.maxLogsPerSecond) {\n          this.listeners[breakpoint.id].enabled = false;\n          setTimeout(() => {\n            // listeners[num] may have been deleted by `clear` during the\n            // async hop. Make sure it is valid before setting a property\n            // on it.\n            if (!shouldStop() && this.listeners[breakpoint.id]) {\n              this.listeners[breakpoint.id].enabled = true;\n            }\n          }, this.config.log.logDelaySeconds * 1000);\n        }\n      }\n    });\n    this.listeners[breakpoint.id] = {\n      enabled: true,\n      listener\n    };\n  }\n\n  disconnect() {\n    this.session.disconnect();\n  }\n\n  numBreakpoints_() {\n    // Tracks the number of stackdriver breakpoints.\n    return Object.keys(this.breakpoints).length;\n  }\n\n  numListeners_() {\n    return Object.keys(this.listeners).length;\n  }\n  /**\n   * Internal breakpoint set function. At this point we have looked up source\n   * maps (if necessary), and scriptPath happens to be a JavaScript path.\n   *\n   * @param {!Breakpoint} breakpoint Debug API Breakpoint object\n   * @param {!MapInfoOutput|null} mapInfo A map that has a \"file\" attribute for\n   *    the path of the output file associated with the given input file\n   * @param {function(string)=} compile optional compile function that can be\n   *    be used to compile source expressions to JavaScript\n   * @param {function(?Error)} cb error-back style callback\n   */\n  // TODO: Fix the documented types to match the function's input types\n  // TODO: Unify this function with setInternal in v8debugapi.ts.\n\n\n  setInternal(breakpoint, mapInfo, compile, cb) {\n    // Parse and validate conditions and watch expressions for correctness and\n    // immutability\n    let ast = null;\n\n    if (breakpoint.condition) {\n      try {\n        // We parse as ES6; even though the underlying V8 version may only\n        // support a subset. This should be fine as the objective of the parse\n        // is to heuristically find side-effects. V8 will raise errors later\n        // if the syntax is invalid. It would have been nice if V8 had made\n        // the parser API available us :(.\n        ast = acorn.parse(breakpoint.condition, {\n          sourceType: 'script',\n          ecmaVersion: 6\n        });\n\n        const validator = require('../util/validator.js');\n\n        if (!validator.isValid(ast)) {\n          return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_CONDITION, utils.messages.DISALLOWED_EXPRESSION);\n        }\n      } catch (e) {\n        const message = utils.messages.SYNTAX_ERROR_IN_CONDITION + e.message;\n        return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_CONDITION, message);\n      }\n    } // Presently it is not possible to precisely disambiguate the script\n    // path from the path provided by the debug server. The issue is that we\n    // don't know the repository root relative to the root filesystem or\n    // relative to the working-directory of the process. We want to make sure\n    // that we are setting the breakpoint that the user intended instead of a\n    // breakpoint in a file that happens to have the same name but is in a\n    // different directory. Until this is addressed between the server and the\n    // debuglet, we are going to assume that repository root === the starting\n    // working directory.\n\n\n    let matchingScript; // TODO: Address the case where `breakpoint.location` is `null`.\n\n    const scripts = utils.findScripts(mapInfo ? mapInfo.file : path.normalize(breakpoint.location.path), this.config, this.fileStats, this.logger);\n\n    if (scripts.length === 0) {\n      return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_SOURCE_LOCATION, utils.messages.SOURCE_FILE_NOT_FOUND);\n    } else if (scripts.length === 1) {\n      // Found the script\n      matchingScript = scripts[0];\n    } else {\n      return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_SOURCE_LOCATION, utils.messages.SOURCE_FILE_AMBIGUOUS);\n    } // The breakpoint protobuf message presently doesn't have a column\n    // property but it may have one in the future.\n    // TODO: Address the case where `breakpoint.location` is `null`.\n\n\n    let column = mapInfo && mapInfo.column ? mapInfo.column : breakpoint.location.column || 1;\n    const line = mapInfo ? mapInfo.line : breakpoint.location.line; // We need to special case breakpoints on the first line. Since Node.js\n    // wraps modules with a function expression, we adjust\n    // to deal with that.\n\n    if (line === 1) {\n      column += debugapi.MODULE_WRAP_PREFIX_LENGTH - 1;\n    } // TODO: Address the case where `breakpoint.location` is `null`.\n    // TODO: Address the case where `fileStats[matchingScript]` is `null`.\n\n\n    if (line >= this.fileStats[matchingScript].lines) {\n      return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_SOURCE_LOCATION, utils.messages.INVALID_LINE_NUMBER + matchingScript + ':' + line + '. Loaded script contained ' + this.fileStats[matchingScript].lines + ' lines. Please ensure' + ' that the snapshot was set in the same code version as the' + ' deployed source.');\n    }\n\n    const result = this.setAndStoreBreakpoint(breakpoint, line, column, matchingScript);\n\n    if (!result) {\n      return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_SOURCE_LOCATION, utils.messages.V8_BREAKPOINT_ERROR);\n    }\n\n    this.breakpoints[breakpoint.id] = new BreakpointData(result.v8BreakpointId, breakpoint, ast, result.locationStr, compile);\n    this.numBreakpoints++;\n    setImmediate(() => {\n      cb(null);\n    }); // success.\n  }\n\n  setAndStoreBreakpoint(breakpoint, line, column, matchingScript) {\n    // location Str will be a JSON string of Stackdriver breakpoint location.\n    // It will be used as key at locationmapper to ensure there will be no\n    // duplicate breakpoints at the same location.\n    const locationStr = JSON.stringify(breakpoint.location);\n    let v8BreakpointId; // v8/inspector breakpoint id\n\n    if (!this.locationMapper[locationStr]) {\n      // The first time when a breakpoint was set to this location.\n      const url = this.inspectorOptions.useWellFormattedUrl ? \"file://\".concat(matchingScript) : matchingScript;\n      const res = this.v8Inspector.setBreakpointByUrl({\n        lineNumber: line - 1,\n        url,\n        columnNumber: column - 1,\n        condition: breakpoint.condition || undefined\n      });\n\n      if (res.error || !res.response) {\n        // Error case.\n        return null;\n      }\n\n      v8BreakpointId = res.response.breakpointId;\n      this.locationMapper[locationStr] = [];\n      this.breakpointMapper[v8BreakpointId] = [];\n    } else {\n      // Breakpoint found at this location. Acquire the v8/inspector breakpoint\n      // id.\n      v8BreakpointId = this.breakpoints[this.locationMapper[locationStr][0]].id;\n    } // Adding current stackdriver breakpoint id to location mapper and\n    // breakpoint mapper.\n\n\n    this.locationMapper[locationStr].push(breakpoint.id);\n    this.breakpointMapper[v8BreakpointId].push(breakpoint.id);\n    return {\n      v8BreakpointId,\n      locationStr\n    };\n  }\n\n  onBreakpointHit(breakpoint, callback, callFrames) {\n    // Breakpoint Hit\n    const start = process.hrtime();\n\n    try {\n      this.captureBreakpointData(breakpoint, callFrames);\n    } catch (err) {\n      return utils.setErrorStatusAndCallback(callback, breakpoint, status_message_1.StatusMessage.BREAKPOINT_SOURCE_LOCATION, utils.messages.CAPTURE_BREAKPOINT_DATA + err);\n    }\n\n    const end = process.hrtime(start);\n    this.logger.info(utils.formatInterval('capture time: ', end));\n    callback(null);\n  }\n\n  captureBreakpointData(breakpoint, callFrames) {\n    const expressionErrors = [];\n    const that = this; // TODO: Address the case where `breakpoint.id` is `null`.\n\n    if (breakpoint.expressions && this.breakpoints[breakpoint.id].compile) {\n      for (let i = 0; i < breakpoint.expressions.length; i++) {\n        try {\n          // TODO: Address the case where `breakpoint.id` is `null`.\n          breakpoint.expressions[i] = // TODO: Address the case where `compile` is `null`.\n          this.breakpoints[breakpoint.id].compile(breakpoint.expressions[i]);\n        } catch (e) {\n          this.logger.info('Unable to compile watch expression >> ' + breakpoint.expressions[i] + ' <<');\n          expressionErrors.push({\n            name: breakpoint.expressions[i],\n            status: new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, 'Error Compiling Expression', true)\n          });\n          breakpoint.expressions.splice(i, 1);\n          i--;\n        }\n      }\n    }\n\n    if (breakpoint.action === 'LOG') {\n      // TODO: This doesn't work with compiled languages if there is an error\n      // compiling one of the expressions in the loop above.\n      if (!breakpoint.expressions) {\n        breakpoint.evaluatedExpressions = [];\n      } else {\n        const frame = callFrames[0];\n        const evaluatedExpressions = breakpoint.expressions.map(exp => {\n          // returnByValue is set to true here so that the JSON string of the\n          // value will be returned to log.\n          const result = state.evaluate(exp, frame, that.v8Inspector, true);\n\n          if (result.error) {\n            return result.error;\n          } else {\n            return result.object.value;\n          }\n        });\n        breakpoint.evaluatedExpressions = evaluatedExpressions;\n      }\n    } else {\n      const captured = state.capture(callFrames, breakpoint, this.config, this.scriptMapper, this.v8Inspector);\n\n      if (breakpoint.location && utils.isJavaScriptFile(breakpoint.location.path)) {\n        breakpoint.location.line = callFrames[0].location.lineNumber + 1;\n      }\n\n      breakpoint.stackFrames = captured.stackFrames; // TODO: This suggests the Status type and Variable type are the same.\n      //       Determine if that is the case.\n\n      breakpoint.variableTable = captured.variableTable;\n      breakpoint.evaluatedExpressions = expressionErrors.concat(captured.evaluatedExpressions);\n    }\n  }\n\n  handleDebugPausedEvent(params) {\n    try {\n      if (!params.hitBreakpoints) return;\n      const v8BreakpointId = params.hitBreakpoints[0];\n      this.breakpointMapper[v8BreakpointId].forEach(id => {\n        if (this.listeners[id].enabled) {\n          this.logger.info('>>>breakpoint hit<<< number: ' + id);\n          this.listeners[id].listener(params.callFrames);\n        }\n      });\n    } catch (e) {\n      this.logger.warn('Internal V8 error on breakpoint event: ' + e);\n    }\n  }\n\n}\n\nexports.InspectorDebugApi = InspectorDebugApi;","map":null,"metadata":{},"sourceType":"script"}