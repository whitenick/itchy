{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst crypto = require(\"crypto\");\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\nconst pickBy = require(\"lodash.pickby\"); // TODO: Make this more precise.\n\n\nconst findit = require('findit2'); // TODO: Make this more precise.\n\n\nconst split = require('split');\n\nclass ScanResultsImpl {\n  /**\n   * Encapsulates the results of a filesystem scan with methods\n   * to easily select scan information or filenames for a\n   * specific subset of the files listed in the scan results.\n   *\n   * @param stats An object that contains filenames\n   *  as keys where each key maps to an object containing the\n   *  hash and number of lines for the specified file.  This\n   *  information is accessed via the `hash` and `lines`\n   *  attributes respectively\n   * @param hash A hashcode computed from the contents of all the files.\n   */\n  constructor(stats, errorMap, hash) {\n    this.stats = stats;\n    this.errorMap = errorMap;\n    this.hash = hash;\n  }\n\n  errors() {\n    return this.errorMap;\n  }\n  /**\n   * Used to get all of the file scan results.\n   */\n\n\n  all() {\n    return this.stats;\n  }\n  /**\n   * Used to get the file scan results for only the files\n   * whose filenames match the specified regex.\n   *\n   * @param {regex} regex The regex that tests a filename\n   *  to determine if the scan results for that filename\n   *  should be included in the returned results.\n   */\n\n\n  selectStats(regex) {\n    return pickBy(this.stats, (_, key) => regex.test(key));\n  }\n  /**\n   * Used to get the only the file paths in the scan results\n   * where the filenames match the specified regex and are\n   * returned with the each relative to the specified base\n   * directory.\n   *\n   * @param {regex} regex The regex that tests a filename to\n   *  determine if the scan results for that filename should\n   *  be included in the returned results.\n   * @param {string} baseDir The absolute path to the directory\n   *  from which all of the returned paths should be relative\n   *  to.\n   */\n\n\n  selectFiles(regex, baseDir) {\n    // ensure the base directory has only a single trailing path separator\n    baseDir = path.normalize(baseDir + path.sep);\n    return Object.keys(this.stats).filter(file => {\n      return file && regex.test(file);\n    }).map(file => {\n      return path.normalize(file).replace(baseDir, '');\n    });\n  }\n\n}\n\nasync function scan(baseDir, regex, precomputedHash) {\n  const fileList = await findFiles(baseDir, regex);\n  return computeStats(fileList, precomputedHash);\n}\n\nexports.scan = scan;\n/**\n * This function accept an array of filenames and computes a unique hash-code\n * based on the contents.\n *\n * @param fileList array of filenames\n * @param precomputedHash if available, hashing operations will be omitted\n * during scan\n */\n// TODO: Typescript: Fix the docs associated with this function to match the\n// call signature\n\nfunction computeStats(fileList, precomputedHash) {\n  return new Promise(async (resolve, reject) => {\n    // return a valid, if fake, result when there are no js files to hash.\n    if (fileList.length === 0) {\n      resolve(new ScanResultsImpl({}, new Map(), 'EMPTY-no-js-files'));\n      return;\n    } // TODO: Address the case where the array contains `undefined`.\n\n\n    const hashes = [];\n    const statistics = {};\n    const errors = new Map();\n\n    for (const filename of fileList) {\n      try {\n        const fileStats = await statsForFile(filename, !precomputedHash);\n\n        if (!precomputedHash) {\n          hashes.push(fileStats.hash);\n        }\n\n        statistics[filename] = fileStats;\n      } catch (err) {\n        errors.set(filename, err);\n      }\n    }\n\n    let hash;\n\n    if (!precomputedHash) {\n      // Sort the hashes to get a deterministic order as the files may\n      // not be in the same order each time we scan the disk.\n      const buffer = hashes.sort().join();\n      const sha1 = crypto.createHash('sha1').update(buffer).digest('hex');\n      hash = 'SHA1-' + sha1;\n    } else {\n      hash = precomputedHash;\n    }\n\n    resolve(new ScanResultsImpl(statistics, errors, hash));\n  });\n}\n/**\n * Given a base-directory, this function scans the subtree and finds all the js\n * files. .git and node_module subdirectories are ignored.\n * @param {!string} baseDir top-level directory to scan\n * @param {!regex} regex the regular expression that specifies the types of\n *  files to find based on their filename\n * @param {!function(?Error, Array<string>)} callback error-back callback\n */\n\n\nfunction findFiles(baseDir, regex) {\n  return new Promise((resolve, reject) => {\n    let error;\n\n    if (!baseDir) {\n      reject(new Error('hasher.findJSFiles requires a baseDir argument'));\n      return;\n    }\n\n    const find = findit(baseDir);\n    const fileList = [];\n    find.on('error', err => {\n      error = err;\n      return;\n    });\n    find.on('directory', (dir, ignore, stop) => {\n      const base = path.basename(dir);\n\n      if (base === '.git' || base === 'node_modules') {\n        stop(); // do not descend\n      }\n    });\n    find.on('file', file => {\n      if (regex.test(file)) {\n        fileList.push(file);\n      }\n    });\n    find.on('end', () => {\n      // Note: the `end` event fires even after an error\n      if (error) {\n        reject(error);\n      } else {\n        resolve(fileList);\n      }\n    });\n  });\n}\n/**\n * Compute a sha hash for the given file and record line counts along the way.\n * @param {string} filename\n * @param {Boolean} shouldHash whether a hash should be computed\n * @param {function} cb errorback style callback which returns the sha string\n * @private\n */\n\n\nfunction statsForFile(filename, shouldHash) {\n  return new Promise((resolve, reject) => {\n    const reader = fs.createReadStream(filename);\n    reader.on('error', err => {\n      reject(err);\n    });\n    reader.on('open', () => {\n      let shasum;\n\n      if (shouldHash) {\n        shasum = crypto.createHash('sha1');\n      }\n\n      let lines = 0;\n      let error;\n      const byLine = reader.pipe(split());\n      byLine.on('error', e => {\n        error = e;\n      });\n      byLine.on('data', d => {\n        if (shouldHash) {\n          shasum.update(d);\n        }\n\n        lines++;\n      });\n      byLine.on('end', () => {\n        if (error) {\n          reject(error);\n        } else {\n          const hash = shouldHash ? shasum.digest('hex') : undefined;\n          resolve({\n            hash,\n            lines\n          });\n        }\n      });\n    });\n  });\n}","map":null,"metadata":{},"sourceType":"script"}