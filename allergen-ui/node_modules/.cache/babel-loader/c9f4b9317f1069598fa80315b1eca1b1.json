{"ast":null,"code":"\"use strict\"; // Copyright 2018, Google, LLC.\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst extend_1 = __importDefault(require(\"extend\"));\n\nconst node_fetch_1 = __importDefault(require(\"node-fetch\"));\n\nconst querystring_1 = __importDefault(require(\"querystring\"));\n\nconst stream_1 = __importDefault(require(\"stream\"));\n\nconst url_1 = __importDefault(require(\"url\"));\n\nconst common_1 = require(\"./common\");\n\nconst isbrowser_1 = require(\"./isbrowser\");\n\nconst retry_1 = require(\"./retry\"); // tslint:disable no-any\n\n\nconst URL = isbrowser_1.isBrowser() ? window.URL : url_1.default.URL;\nconst fetch = isbrowser_1.isBrowser() ? window.fetch : node_fetch_1.default; // tslint:disable-next-line variable-name\n\nlet HttpsProxyAgent; // Figure out if we should be using a proxy. Only if it's required, load\n// the https-proxy-agent module as it adds startup cost.\n\nfunction loadProxy() {\n  const proxy = process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy;\n\n  if (proxy) {\n    HttpsProxyAgent = require('https-proxy-agent');\n  }\n\n  return proxy;\n}\n\nloadProxy();\n\nclass Gaxios {\n  /**\n   * The Gaxios class is responsible for making HTTP requests.\n   * @param defaults The default set of options to be used for this instance.\n   */\n  constructor(defaults) {\n    this.agentCache = new Map();\n    this.defaults = defaults || {};\n  }\n  /**\n   * Perform an HTTP request with the given options.\n   * @param opts Set of HTTP options that will be used for this HTTP request.\n   */\n\n\n  async request(opts = {}) {\n    opts = this.validateOpts(opts);\n\n    try {\n      let translatedResponse;\n\n      if (opts.adapter) {\n        translatedResponse = await opts.adapter(opts);\n      } else {\n        const res = await fetch(opts.url, opts);\n        const data = await this.getResponseData(opts, res);\n        translatedResponse = this.translateResponse(opts, res, data);\n      }\n\n      if (!opts.validateStatus(translatedResponse.status)) {\n        throw new common_1.GaxiosError(\"Request failed with status code \".concat(translatedResponse.status), opts, translatedResponse);\n      }\n\n      return translatedResponse;\n    } catch (e) {\n      const err = e;\n      err.config = opts;\n\n      const _ref = await retry_1.getRetryConfig(e),\n            shouldRetry = _ref.shouldRetry,\n            config = _ref.config;\n\n      if (shouldRetry && config) {\n        err.config.retryConfig.currentRetryAttempt = config.retryConfig.currentRetryAttempt;\n        return this.request(err.config);\n      }\n\n      throw err;\n    }\n  }\n\n  async getResponseData(opts, res) {\n    switch (opts.responseType) {\n      case 'stream':\n        return res.body;\n\n      case 'json':\n        let data = await res.text();\n\n        try {\n          data = JSON.parse(data);\n        } catch (e) {}\n\n        return data;\n\n      case 'arraybuffer':\n        return res.arrayBuffer();\n\n      case 'blob':\n        return res.blob();\n\n      default:\n        return res.text();\n    }\n  }\n  /**\n   * Validates the options, and merges them with defaults.\n   * @param opts The original options passed from the client.\n   */\n\n\n  validateOpts(options) {\n    const opts = extend_1.default(true, {}, this.defaults, options);\n\n    if (!opts.url) {\n      throw new Error('URL is required.');\n    } // baseUrl has been deprecated, remove in 2.0\n\n\n    const baseUrl = opts.baseUrl || opts.baseURL;\n\n    if (baseUrl) {\n      opts.url = baseUrl + opts.url;\n    }\n\n    const parsedUrl = new URL(opts.url);\n    opts.url = \"\".concat(parsedUrl.origin).concat(parsedUrl.pathname);\n    opts.params = extend_1.default(querystring_1.default.parse(parsedUrl.search.substr(1)), // removes leading ?\n    opts.params);\n    opts.paramsSerializer = opts.paramsSerializer || this.paramsSerializer;\n\n    if (opts.params) {\n      parsedUrl.search = opts.paramsSerializer(opts.params);\n    }\n\n    opts.url = parsedUrl.href;\n\n    if (typeof options.maxContentLength === 'number') {\n      opts.size = options.maxContentLength;\n    }\n\n    if (typeof options.maxRedirects === 'number') {\n      opts.follow = options.maxRedirects;\n    }\n\n    opts.headers = opts.headers || {};\n\n    if (opts.data) {\n      if (this.isReadableStream(opts.data)) {\n        opts.body = opts.data;\n      } else if (typeof opts.data === 'object') {\n        opts.body = JSON.stringify(opts.data);\n        opts.headers['Content-Type'] = 'application/json';\n      } else {\n        opts.body = opts.data;\n      }\n    }\n\n    opts.validateStatus = opts.validateStatus || this.validateStatus;\n    opts.responseType = opts.responseType || 'json';\n\n    if (!opts.headers['Accept'] && opts.responseType === 'json') {\n      opts.headers['Accept'] = 'application/json';\n    }\n\n    opts.method = opts.method || 'GET';\n    const proxy = loadProxy();\n\n    if (proxy) {\n      if (this.agentCache.has(proxy)) {\n        opts.agent = this.agentCache.get(proxy);\n      } else {\n        opts.agent = new HttpsProxyAgent(proxy);\n        this.agentCache.set(proxy, opts.agent);\n      }\n    }\n\n    return opts;\n  }\n  /**\n   * By default, throw for any non-2xx status code\n   * @param status status code from the HTTP response\n   */\n\n\n  validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n  /**\n   * Encode a set of key/value pars into a querystring format (?foo=bar&baz=boo)\n   * @param params key value pars to encode\n   */\n\n\n  paramsSerializer(params) {\n    return querystring_1.default.stringify(params);\n  }\n\n  isReadableStream(obj) {\n    return obj instanceof stream_1.default.Readable && typeof obj._read === 'function';\n  }\n\n  translateResponse(opts, res, data) {\n    // headers need to be converted from a map to an obj\n    const headers = {};\n    res.headers.forEach((value, key) => {\n      headers[key] = value;\n    });\n    return {\n      config: opts,\n      data: data,\n      headers,\n      status: res.status,\n      statusText: res.statusText\n    };\n  }\n\n}\n\nexports.Gaxios = Gaxios;","map":null,"metadata":{},"sourceType":"script"}