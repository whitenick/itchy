{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*!\n * @module common/util\n */\n\nconst projectify_1 = require(\"@google-cloud/projectify\");\n\nconst ent = require(\"ent\");\n\nconst extend = require(\"extend\");\n\nconst google_auth_library_1 = require(\"google-auth-library\");\n\nconst retryRequest = require(\"retry-request\");\n\nconst stream_1 = require(\"stream\");\n\nconst teeny_request_1 = require(\"teeny-request\");\n\nconst duplexify = require('duplexify');\n\nconst requestDefaults = {\n  timeout: 60000,\n  gzip: true,\n  forever: true,\n  pool: {\n    maxSockets: Infinity\n  }\n};\n/**\n * Custom error type for API errors.\n *\n * @param {object} errorBody - Error object.\n */\n\nclass ApiError extends Error {\n  constructor(errorBodyOrMessage) {\n    super();\n\n    if (typeof errorBodyOrMessage !== 'object') {\n      this.message = errorBodyOrMessage || '';\n      return;\n    }\n\n    const errorBody = errorBodyOrMessage;\n    this.code = errorBody.code;\n    this.errors = errorBody.errors;\n    this.response = errorBody.response;\n\n    try {\n      this.errors = JSON.parse(this.response.body).error.errors;\n    } catch (e) {\n      this.errors = errorBody.errors;\n    }\n\n    this.message = ApiError.createMultiErrorMessage(errorBody, this.errors);\n  }\n  /**\n   * Pieces together an error message by combining all unique error messages\n   * returned from a single GoogleError\n   *\n   * @private\n   *\n   * @param {GoogleErrorBody} err The original error.\n   * @param {GoogleInnerError[]} [errors] Inner errors, if any.\n   * @returns {string}\n   */\n\n\n  static createMultiErrorMessage(err, errors) {\n    const messages = new Set();\n\n    if (err.message) {\n      messages.add(err.message);\n    }\n\n    if (errors && errors.length) {\n      errors.forEach(({\n        message\n      }) => messages.add(message));\n    } else if (err.response && err.response.body) {\n      messages.add(ent.decode(err.response.body.toString()));\n    } else if (!err.message) {\n      messages.add('A failure occurred during this request.');\n    }\n\n    let messageArr = Array.from(messages);\n\n    if (messageArr.length > 1) {\n      messageArr = messageArr.map((message, i) => \"    \".concat(i + 1, \". \").concat(message));\n      messageArr.unshift('Multiple errors occurred during the request. Please see the `errors` array for complete details.\\n');\n      messageArr.push('\\n');\n    }\n\n    return messageArr.join('\\n');\n  }\n\n}\n\nexports.ApiError = ApiError;\n/**\n * Custom error type for partial errors returned from the API.\n *\n * @param {object} b - Error object.\n */\n\nclass PartialFailureError extends Error {\n  constructor(b) {\n    super();\n    const errorObject = b;\n    this.errors = errorObject.errors;\n    this.name = 'PartialFailureError';\n    this.response = errorObject.response;\n    this.message = ApiError.createMultiErrorMessage(errorObject, this.errors);\n  }\n\n}\n\nexports.PartialFailureError = PartialFailureError;\n\nclass Util {\n  constructor() {\n    this.ApiError = ApiError;\n    this.PartialFailureError = PartialFailureError;\n  }\n  /**\n   * No op.\n   *\n   * @example\n   * function doSomething(callback) {\n   *   callback = callback || noop;\n   * }\n   */\n\n\n  noop() {}\n  /**\n   * Uniformly process an API response.\n   *\n   * @param {*} err - Error value.\n   * @param {*} resp - Response value.\n   * @param {*} body - Body value.\n   * @param {function} callback - The callback function.\n   */\n\n\n  handleResp(err, resp, body, callback) {\n    callback = callback || util.noop;\n    const parsedResp = extend(true, {\n      err: err || null\n    }, resp && util.parseHttpRespMessage(resp), body && util.parseHttpRespBody(body)); // Assign the parsed body to resp.body, even if { json: false } was passed\n    // as a request option.\n    // We assume that nobody uses the previously unparsed value of resp.body.\n\n    if (!parsedResp.err && resp && typeof parsedResp.body === 'object') {\n      parsedResp.resp.body = parsedResp.body;\n    }\n\n    callback(parsedResp.err, parsedResp.body, parsedResp.resp);\n  }\n  /**\n   * Sniff an incoming HTTP response message for errors.\n   *\n   * @param {object} httpRespMessage - An incoming HTTP response message from `request`.\n   * @return {object} parsedHttpRespMessage - The parsed response.\n   * @param {?error} parsedHttpRespMessage.err - An error detected.\n   * @param {object} parsedHttpRespMessage.resp - The original response object.\n   */\n\n\n  parseHttpRespMessage(httpRespMessage) {\n    const parsedHttpRespMessage = {\n      resp: httpRespMessage\n    };\n\n    if (httpRespMessage.statusCode < 200 || httpRespMessage.statusCode > 299) {\n      // Unknown error. Format according to ApiError standard.\n      parsedHttpRespMessage.err = new ApiError({\n        errors: new Array(),\n        code: httpRespMessage.statusCode,\n        message: httpRespMessage.statusMessage,\n        response: httpRespMessage\n      });\n    }\n\n    return parsedHttpRespMessage;\n  }\n  /**\n   * Parse the response body from an HTTP request.\n   *\n   * @param {object} body - The response body.\n   * @return {object} parsedHttpRespMessage - The parsed response.\n   * @param {?error} parsedHttpRespMessage.err - An error detected.\n   * @param {object} parsedHttpRespMessage.body - The original body value provided\n   *     will try to be JSON.parse'd. If it's successful, the parsed value will\n   * be returned here, otherwise the original value.\n   */\n\n\n  parseHttpRespBody(body) {\n    const parsedHttpRespBody = {\n      body\n    };\n\n    if (typeof body === 'string') {\n      try {\n        parsedHttpRespBody.body = JSON.parse(body);\n      } catch (err) {\n        parsedHttpRespBody.err = new ApiError('Cannot parse JSON response');\n      }\n    }\n\n    if (parsedHttpRespBody.body && parsedHttpRespBody.body.error) {\n      // Error from JSON API.\n      parsedHttpRespBody.err = new ApiError(parsedHttpRespBody.body.error);\n    }\n\n    return parsedHttpRespBody;\n  }\n  /**\n   * Take a Duplexify stream, fetch an authenticated connection header, and\n   * create an outgoing writable stream.\n   *\n   * @param {Duplexify} dup - Duplexify stream.\n   * @param {object} options - Configuration object.\n   * @param {module:common/connection} options.connection - A connection instance used to get a token with and send the request through.\n   * @param {object} options.metadata - Metadata to send at the head of the request.\n   * @param {object} options.request - Request object, in the format of a standard Node.js http.request() object.\n   * @param {string=} options.request.method - Default: \"POST\".\n   * @param {string=} options.request.qs.uploadType - Default: \"multipart\".\n   * @param {string=} options.streamContentType - Default: \"application/octet-stream\".\n   * @param {function} onComplete - Callback, executed after the writable Request stream has completed.\n   */\n\n\n  makeWritableStream(dup, options, onComplete) {\n    onComplete = onComplete || util.noop;\n    const writeStream = new stream_1.PassThrough();\n    dup.setWritable(writeStream);\n    const defaultReqOpts = {\n      method: 'POST',\n      qs: {\n        uploadType: 'multipart'\n      },\n      timeout: 0,\n      maxRetries: 0\n    };\n    const metadata = options.metadata || {};\n    const reqOpts = extend(true, defaultReqOpts, options.request, {\n      multipart: [{\n        'Content-Type': 'application/json',\n        body: JSON.stringify(metadata)\n      }, {\n        'Content-Type': metadata.contentType || 'application/octet-stream',\n        body: writeStream\n      }]\n    });\n    options.makeAuthenticatedRequest(reqOpts, {\n      onAuthenticated(err, authenticatedReqOpts) {\n        if (err) {\n          dup.destroy(err);\n          return;\n        }\n\n        const request = teeny_request_1.teenyRequest.defaults(requestDefaults);\n        request(authenticatedReqOpts, (err, resp, body) => {\n          util.handleResp(err, resp, body, (err, data) => {\n            if (err) {\n              dup.destroy(err);\n              return;\n            }\n\n            dup.emit('response', resp);\n            onComplete(data);\n          });\n        });\n      }\n\n    });\n  }\n  /**\n   * Returns true if the API request should be retried, given the error that was\n   * given the first time the request was attempted. This is used for rate limit\n   * related errors as well as intermittent server errors.\n   *\n   * @param {error} err - The API error to check if it is appropriate to retry.\n   * @return {boolean} True if the API request should be retried, false otherwise.\n   */\n\n\n  shouldRetryRequest(err) {\n    if (err) {\n      if ([429, 500, 502, 503].indexOf(err.code) !== -1) {\n        return true;\n      }\n\n      if (err.errors) {\n        for (const e of err.errors) {\n          const reason = e.reason;\n\n          if (reason === 'rateLimitExceeded') {\n            return true;\n          }\n\n          if (reason === 'userRateLimitExceeded') {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Get a function for making authenticated requests.\n   *\n   * @param {object} config - Configuration object.\n   * @param {boolean=} config.autoRetry - Automatically retry requests if the\n   *     response is related to rate limits or certain intermittent server\n   * errors. We will exponentially backoff subsequent requests by default.\n   * (default: true)\n   * @param {object=} config.credentials - Credentials object.\n   * @param {boolean=} config.customEndpoint - If true, just return the provided request options. Default: false.\n   * @param {string=} config.email - Account email address, required for PEM/P12 usage.\n   * @param {number=} config.maxRetries - Maximum number of automatic retries attempted before returning the error. (default: 3)\n   * @param {string=} config.keyFile - Path to a .json, .pem, or .p12 keyfile.\n   * @param {array} config.scopes - Array of scopes required for the API.\n   */\n\n\n  makeAuthenticatedRequestFactory(config) {\n    const googleAutoAuthConfig = extend({}, config);\n\n    if (googleAutoAuthConfig.projectId === '{{projectId}}') {\n      delete googleAutoAuthConfig.projectId;\n    }\n\n    const authClient = googleAutoAuthConfig.authClient || new google_auth_library_1.GoogleAuth(googleAutoAuthConfig);\n\n    function makeAuthenticatedRequest(reqOpts, optionsOrCallback) {\n      let stream;\n      const reqConfig = extend({}, config);\n      let activeRequest_;\n\n      if (!optionsOrCallback) {\n        stream = duplexify();\n        reqConfig.stream = stream;\n      }\n\n      const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : undefined;\n      const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : undefined;\n\n      const onAuthenticated = (err, authenticatedReqOpts) => {\n        const autoAuthFailed = err && err.message.indexOf('Could not load the default credentials') > -1;\n\n        if (autoAuthFailed) {\n          // Even though authentication failed, the API might not actually\n          // care.\n          authenticatedReqOpts = reqOpts;\n        }\n\n        if (!err || autoAuthFailed) {\n          // tslint:disable-next-line:no-any\n          let projectId = authClient._cachedProjectId;\n\n          if (config.projectId && config.projectId !== '{{projectId}}') {\n            projectId = config.projectId;\n          }\n\n          try {\n            authenticatedReqOpts = util.decorateRequest(authenticatedReqOpts, projectId);\n            err = null;\n          } catch (e) {\n            // A projectId was required, but we don't have one.\n            // Re-use the \"Could not load the default credentials error\" if\n            // auto auth failed.\n            err = err || e;\n          }\n        }\n\n        if (err) {\n          if (stream) {\n            stream.destroy(err);\n          } else {\n            const fn = options && options.onAuthenticated ? options.onAuthenticated : callback;\n            fn(err);\n          }\n\n          return;\n        }\n\n        if (options && options.onAuthenticated) {\n          options.onAuthenticated(null, authenticatedReqOpts);\n        } else {\n          activeRequest_ = util.makeRequest(authenticatedReqOpts, reqConfig, callback);\n        }\n      };\n\n      if (reqConfig.customEndpoint) {\n        // Using a custom API override. Do not use `google-auth-library` for\n        // authentication. (ex: connecting to a local Datastore server)\n        onAuthenticated(null, reqOpts);\n      } else {\n        authClient.authorizeRequest(reqOpts).then(res => {\n          const opts = extend(true, {}, reqOpts, res);\n          onAuthenticated(null, opts);\n        }, err => {\n          onAuthenticated(err);\n        });\n      }\n\n      if (stream) {\n        return stream;\n      }\n\n      return {\n        abort() {\n          setImmediate(() => {\n            if (activeRequest_) {\n              activeRequest_.abort();\n              activeRequest_ = null;\n            }\n          });\n        }\n\n      };\n    }\n\n    const mar = makeAuthenticatedRequest;\n    mar.getCredentials = authClient.getCredentials.bind(authClient);\n    mar.authClient = authClient;\n    return mar;\n  }\n  /**\n   * Make a request through the `retryRequest` module with built-in error\n   * handling and exponential back off.\n   *\n   * @param {object} reqOpts - Request options in the format `request` expects.\n   * @param {object=} config - Configuration object.\n   * @param {boolean=} config.autoRetry - Automatically retry requests if the\n   *     response is related to rate limits or certain intermittent server\n   * errors. We will exponentially backoff subsequent requests by default.\n   * (default: true)\n   * @param {number=} config.maxRetries - Maximum number of automatic retries\n   *     attempted before returning the error. (default: 3)\n   * @param {object=} config.request - HTTP module for request calls.\n   * @param {function} callback - The callback function.\n   */\n\n\n  makeRequest(reqOpts, config, callback) {\n    const options = {\n      request: teeny_request_1.teenyRequest.defaults(requestDefaults),\n      retries: config.autoRetry !== false ? config.maxRetries || 3 : 0,\n\n      shouldRetryFn(httpRespMessage) {\n        const err = util.parseHttpRespMessage(httpRespMessage).err;\n        return err && util.shouldRetryRequest(err);\n      }\n\n    };\n\n    if (typeof reqOpts.maxRetries === 'number') {\n      options.retries = reqOpts.maxRetries;\n    }\n\n    if (!config.stream) {\n      return retryRequest(reqOpts, options, (err, response, body) => {\n        util.handleResp(err, response, body, callback);\n      });\n    }\n\n    const dup = config.stream; // tslint:disable-next-line:no-any\n\n    let requestStream;\n    const isGetRequest = (reqOpts.method || 'GET').toUpperCase() === 'GET';\n\n    if (isGetRequest) {\n      requestStream = retryRequest(reqOpts, options);\n      dup.setReadable(requestStream);\n    } else {\n      // Streaming writable HTTP requests cannot be retried.\n      requestStream = options.request(reqOpts);\n      dup.setWritable(requestStream);\n    } // Replay the Request events back to the stream.\n\n\n    requestStream.on('error', dup.destroy.bind(dup)).on('response', dup.emit.bind(dup, 'response')).on('complete', dup.emit.bind(dup, 'complete'));\n    dup.abort = requestStream.abort;\n    return dup;\n  }\n  /**\n   * Decorate the options about to be made in a request.\n   *\n   * @param {object} reqOpts - The options to be passed to `request`.\n   * @param {string} projectId - The project ID.\n   * @return {object} reqOpts - The decorated reqOpts.\n   */\n\n\n  decorateRequest(reqOpts, projectId) {\n    delete reqOpts.autoPaginate;\n    delete reqOpts.autoPaginateVal;\n    delete reqOpts.objectMode;\n\n    if (reqOpts.qs !== null && typeof reqOpts.qs === 'object') {\n      delete reqOpts.qs.autoPaginate;\n      delete reqOpts.qs.autoPaginateVal;\n      reqOpts.qs = projectify_1.replaceProjectIdToken(reqOpts.qs, projectId);\n    }\n\n    if (Array.isArray(reqOpts.multipart)) {\n      reqOpts.multipart = reqOpts.multipart.map(part => {\n        return projectify_1.replaceProjectIdToken(part, projectId);\n      });\n    }\n\n    if (reqOpts.json !== null && typeof reqOpts.json === 'object') {\n      delete reqOpts.json.autoPaginate;\n      delete reqOpts.json.autoPaginateVal;\n      reqOpts.json = projectify_1.replaceProjectIdToken(reqOpts.json, projectId);\n    }\n\n    reqOpts.uri = projectify_1.replaceProjectIdToken(reqOpts.uri, projectId);\n    return reqOpts;\n  } // tslint:disable-next-line:no-any\n\n\n  isCustomType(unknown, module) {\n    function getConstructorName(obj) {\n      return obj.constructor && obj.constructor.name.toLowerCase();\n    }\n\n    const moduleNameParts = module.split('/');\n    const parentModuleName = moduleNameParts[0] && moduleNameParts[0].toLowerCase();\n    const subModuleName = moduleNameParts[1] && moduleNameParts[1].toLowerCase();\n\n    if (subModuleName && getConstructorName(unknown) !== subModuleName) {\n      return false;\n    }\n\n    let walkingModule = unknown;\n\n    while (true) {\n      if (getConstructorName(walkingModule) === parentModuleName) {\n        return true;\n      }\n\n      walkingModule = walkingModule.parent;\n\n      if (!walkingModule) {\n        return false;\n      }\n    }\n  }\n  /**\n   * Create a properly-formatted User-Agent string from a package.json file.\n   *\n   * @param {object} packageJson - A module's package.json file.\n   * @return {string} userAgent - The formatted User-Agent string.\n   */\n\n\n  getUserAgentFromPackageJson(packageJson) {\n    const hyphenatedPackageName = packageJson.name.replace('@google-cloud', 'gcloud-node') // For legacy purposes.\n    .replace('/', '-'); // For UA spec-compliance purposes.\n\n    return hyphenatedPackageName + '/' + packageJson.version;\n  }\n  /**\n   * Given two parameters, figure out if this is either:\n   *  - Just a callback function\n   *  - An options object, and then a callback function\n   * @param optionsOrCallback An options object or callback.\n   * @param cb A potentially undefined callback.\n   */\n\n\n  maybeOptionsOrCallback(optionsOrCallback, cb) {\n    return typeof optionsOrCallback === 'function' ? [{}, optionsOrCallback] : [optionsOrCallback, cb];\n  }\n\n}\n\nexports.Util = Util;\nconst util = new Util();\nexports.util = util;","map":null,"metadata":{},"sourceType":"script"}