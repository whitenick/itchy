{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _slicedToArray = require(\"/Users/nickwhite/go/antipathy/allergen-ui/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*!\n * @module common/service-object\n */\n\nconst promisify_1 = require(\"@google-cloud/promisify\");\n\nconst arrify = require(\"arrify\");\n\nconst events_1 = require(\"events\");\n\nconst extend = require(\"extend\");\n\nconst util_1 = require(\"./util\");\n/**\n * ServiceObject is a base class, meant to be inherited from by a \"service\n * object,\" like a BigQuery dataset or Storage bucket.\n *\n * Most of the time, these objects share common functionality; they can be\n * created or deleted, and you can get or set their metadata.\n *\n * By inheriting from this class, a service object will be extended with these\n * shared behaviors. Note that any method can be overridden when the service\n * object requires specific behavior.\n */\n// tslint:disable-next-line no-any\n\n\nclass ServiceObject extends events_1.EventEmitter {\n  /*\n   * @constructor\n   * @alias module:common/service-object\n   *\n   * @private\n   *\n   * @param {object} config - Configuration object.\n   * @param {string} config.baseUrl - The base URL to make API requests to.\n   * @param {string} config.createMethod - The method which creates this object.\n   * @param {string=} config.id - The identifier of the object. For example, the\n   *     name of a Storage bucket or Pub/Sub topic.\n   * @param {object=} config.methods - A map of each method name that should be inherited.\n   * @param {object} config.methods[].reqOpts - Default request options for this\n   *     particular method. A common use case is when `setMetadata` requires a\n   *     `PUT` method to override the default `PATCH`.\n   * @param {object} config.parent - The parent service instance. For example, an\n   *     instance of Storage if the object is Bucket.\n   */\n  constructor(config) {\n    super();\n    this.metadata = {};\n    this.baseUrl = config.baseUrl;\n    this.parent = config.parent; // Parent class.\n\n    this.id = config.id; // Name or ID (e.g. dataset ID, bucket name, etc).\n\n    this.createMethod = config.createMethod;\n    this.methods = config.methods || {};\n    this.interceptors = [];\n    this.Promise = this.parent ? this.parent.Promise : undefined;\n\n    if (config.methods) {\n      Object.getOwnPropertyNames(ServiceObject.prototype).filter(methodName => {\n        return (// All ServiceObjects need `request`.\n          // clang-format off\n          !/^request/.test(methodName) && // clang-format on\n          // The ServiceObject didn't redefine the method.\n          // tslint:disable-next-line no-any\n          this[methodName] === // tslint:disable-next-line no-any\n          ServiceObject.prototype[methodName] && // This method isn't wanted.\n          !config.methods[methodName]\n        );\n      }).forEach(methodName => {\n        // tslint:disable-next-line no-any\n        this[methodName] = undefined;\n      });\n    }\n  }\n\n  create(optionsOrCallback, callback) {\n    const self = this;\n    const args = [this.id];\n\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    }\n\n    if (typeof optionsOrCallback === 'object') {\n      args.push(optionsOrCallback);\n    } // Wrap the callback to return *this* instance of the object, not the\n    // newly-created one.\n    // tslint: disable-next-line no-any\n\n\n    function onCreate(...args) {\n      const err = args[0],\n            instance = args[1];\n\n      if (!err) {\n        self.metadata = instance.metadata;\n        args[1] = self; // replace the created `instance` with this one.\n      }\n\n      callback(...args);\n    }\n\n    args.push(onCreate);\n    this.createMethod.apply(null, args);\n  }\n\n  delete(optionsOrCallback, cb) {\n    const _util_1$util$maybeOpt = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb),\n          _util_1$util$maybeOpt2 = _slicedToArray(_util_1$util$maybeOpt, 2),\n          options = _util_1$util$maybeOpt2[0],\n          callback = _util_1$util$maybeOpt2[1];\n\n    const methodConfig = typeof this.methods.delete === 'object' && this.methods.delete || {};\n    const reqOpts = extend(true, {\n      method: 'DELETE',\n      uri: ''\n    }, methodConfig.reqOpts, {\n      qs: options\n    }); // The `request` method may have been overridden to hold any special\n    // behavior. Ensure we call the original `request` method.\n\n    ServiceObject.prototype.request.call(this, reqOpts, callback);\n  }\n\n  exists(optionsOrCallback, cb) {\n    const _util_1$util$maybeOpt3 = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb),\n          _util_1$util$maybeOpt4 = _slicedToArray(_util_1$util$maybeOpt3, 2),\n          options = _util_1$util$maybeOpt4[0],\n          callback = _util_1$util$maybeOpt4[1];\n\n    this.get(options, err => {\n      if (err) {\n        if (err.code === 404) {\n          callback(null, false);\n        } else {\n          callback(err);\n        }\n\n        return;\n      }\n\n      callback(null, true);\n    });\n  }\n\n  get(optionsOrCallback, cb) {\n    const self = this;\n\n    const _util_1$util$maybeOpt5 = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb),\n          _util_1$util$maybeOpt6 = _slicedToArray(_util_1$util$maybeOpt5, 2),\n          opts = _util_1$util$maybeOpt6[0],\n          callback = _util_1$util$maybeOpt6[1];\n\n    const options = Object.assign({}, opts);\n    const autoCreate = options.autoCreate && typeof this.create === 'function';\n    delete options.autoCreate;\n\n    function onCreate(err, instance, apiResponse) {\n      if (err) {\n        if (err.code === 409) {\n          self.get(options, callback);\n          return;\n        }\n\n        callback(err, null, apiResponse);\n        return;\n      }\n\n      callback(null, instance, apiResponse);\n    }\n\n    this.getMetadata(options, (err, metadata) => {\n      if (err) {\n        if (err.code === 404 && autoCreate) {\n          const args = [];\n\n          if (Object.keys(options).length > 0) {\n            args.push(options);\n          }\n\n          args.push(onCreate);\n          self.create(...args);\n          return;\n        }\n\n        callback(err, null, metadata);\n        return;\n      }\n\n      callback(null, self, metadata);\n    });\n  }\n\n  getMetadata(optionsOrCallback, cb) {\n    const _util_1$util$maybeOpt7 = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb),\n          _util_1$util$maybeOpt8 = _slicedToArray(_util_1$util$maybeOpt7, 2),\n          options = _util_1$util$maybeOpt8[0],\n          callback = _util_1$util$maybeOpt8[1];\n\n    const methodConfig = typeof this.methods.getMetadata === 'object' && this.methods.getMetadata || {};\n    const reqOpts = extend(true, {\n      uri: ''\n    }, methodConfig.reqOpts, {\n      qs: options\n    }); // The `request` method may have been overridden to hold any special\n    // behavior. Ensure we call the original `request` method.\n\n    ServiceObject.prototype.request.call(this, reqOpts, (err, body, res) => {\n      this.metadata = body;\n      callback(err, this.metadata, res);\n    });\n  }\n\n  setMetadata(metadata, optionsOrCallback, cb) {\n    const _util_1$util$maybeOpt9 = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb),\n          _util_1$util$maybeOpt10 = _slicedToArray(_util_1$util$maybeOpt9, 2),\n          options = _util_1$util$maybeOpt10[0],\n          callback = _util_1$util$maybeOpt10[1];\n\n    const methodConfig = typeof this.methods.setMetadata === 'object' && this.methods.setMetadata || {};\n    const reqOpts = extend(true, {}, {\n      method: 'PATCH',\n      uri: ''\n    }, methodConfig.reqOpts, {\n      json: metadata,\n      qs: options\n    }); // The `request` method may have been overridden to hold any special\n    // behavior. Ensure we call the original `request` method.\n\n    ServiceObject.prototype.request.call(this, reqOpts, (err, body, res) => {\n      this.metadata = body;\n      callback(err, this.metadata, res);\n    });\n  }\n\n  request_(reqOpts, callback) {\n    reqOpts = extend(true, {}, reqOpts);\n    const isAbsoluteUrl = reqOpts.uri.indexOf('http') === 0;\n    const uriComponents = [this.baseUrl, this.id || '', reqOpts.uri];\n\n    if (isAbsoluteUrl) {\n      uriComponents.splice(0, uriComponents.indexOf(reqOpts.uri));\n    }\n\n    reqOpts.uri = uriComponents.filter(x => x.trim()) // Limit to non-empty strings.\n    .map(uriComponent => {\n      const trimSlashesRegex = /^\\/*|\\/*$/g;\n      return uriComponent.replace(trimSlashesRegex, '');\n    }).join('/');\n    const childInterceptors = arrify(reqOpts.interceptors_);\n    const localInterceptors = [].slice.call(this.interceptors);\n    reqOpts.interceptors_ = childInterceptors.concat(localInterceptors);\n\n    if (reqOpts.shouldReturnStream) {\n      return this.parent.requestStream(reqOpts);\n    }\n\n    this.parent.request(reqOpts, callback);\n  }\n\n  request(reqOpts, callback) {\n    this.request_(reqOpts, callback);\n  }\n  /**\n   * Make an authenticated API request.\n   *\n   * @param {object} reqOpts - Request options that are passed to `request`.\n   * @param {string} reqOpts.uri - A URI relative to the baseUrl.\n   */\n\n\n  requestStream(reqOpts) {\n    const opts = extend(true, reqOpts, {\n      shouldReturnStream: true\n    });\n    return this.request_(opts);\n  }\n\n}\n\nexports.ServiceObject = ServiceObject;\npromisify_1.promisifyAll(ServiceObject);","map":null,"metadata":{},"sourceType":"script"}