{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst is_1 = require(\"@sindresorhus/is\");\n\nconst util = require(\"util\");\n\nconst vm = require(\"vm\");\n\nconst status_message_1 = require(\"../../client/stackdriver/status-message\");\n\nconst debug_assert_1 = require(\"../util/debug-assert\");\n\nconst assert = debug_assert_1.debugAssert(!!process.env.CLOUD_DEBUG_ASSERTIONS); // Error message indices into the resolved variable table.\n\nconst BUFFER_FULL_MESSAGE_INDEX = 0;\nconst NATIVE_PROPERTY_MESSAGE_INDEX = 1;\nconst GETTER_MESSAGE_INDEX = 2;\nconst ARG_LOCAL_LIMIT_MESSAGE_INDEX = 3;\n/**\n * Checks that the provided expressions will not have side effects and\n * then evaluates the expression in the current execution context.\n *\n * @return an object with error and mirror fields.\n */\n\nfunction evaluate(expression, frame) {\n  // First validate the expression to make sure it doesn't mutate state\n  const acorn = require('acorn');\n\n  try {\n    const ast = acorn.parse(expression, {\n      sourceType: 'script'\n    });\n\n    const validator = require('../util/validator');\n\n    if (!validator.isValid(ast)) {\n      return {\n        error: 'Expression not allowed'\n      };\n    }\n  } catch (err) {\n    return {\n      error: err.message\n    };\n  } // Now actually ask V8 to evaluate the expression\n\n\n  try {\n    const mirror = frame.evaluate(expression);\n    return {\n      error: null,\n      mirror\n    };\n  } catch (error) {\n    return {\n      error\n    };\n  }\n}\n\nexports.evaluate = evaluate;\n\nclass StateResolver {\n  /**\n   * @param {!Object} execState\n   * @param {Array<string>} expressions\n   * @param {!Object} config\n   * @constructor\n   */\n  constructor(execState, expressions, config, v8debug) {\n    this.state = execState;\n    this.expressions = expressions;\n    this.config = config;\n    this.ctx = v8debug;\n    this.evaluatedExpressions = [];\n    this.totalSize = 0;\n    this.messageTable = [];\n    this.messageTable[BUFFER_FULL_MESSAGE_INDEX] = {\n      status: new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, 'Max data size reached', true)\n    };\n    this.messageTable[NATIVE_PROPERTY_MESSAGE_INDEX] = {\n      status: new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, 'Native properties are not available', true)\n    };\n    this.messageTable[GETTER_MESSAGE_INDEX] = {\n      status: new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, 'Properties with getters are not available', true)\n    };\n    this.messageTable[ARG_LOCAL_LIMIT_MESSAGE_INDEX] = {\n      status: new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, 'Locals and arguments are only displayed for the ' + 'top `config.capture.maxExpandFrames=' + config.capture.maxExpandFrames + '` stack frames.', true)\n    }; // TODO: Determine why _extend is used here\n\n    this.resolvedVariableTable = util._extend([], this.messageTable);\n    this.rawVariableTable = this.messageTable.map(() => {\n      return null;\n    }); // This constructor is only used in situations where the legacy vm\n    // interface is used that has the `runInDebugContext` method.\n\n    this.scopeType = vm.runInDebugContext('ScopeType');\n  }\n  /**\n   * Captures the stack and current execution state.\n   *\n   * @return an object with stackFrames, variableTable, and\n   *         evaluatedExpressions fields\n   */\n\n\n  capture_() {\n    const that = this; // Evaluate the watch expressions\n\n    const evalIndexSet = new Set();\n\n    if (that.expressions) {\n      that.expressions.forEach((expression, index2) => {\n        const result = evaluate(expression, that.state.frame(0));\n        let evaluated;\n\n        if (result.error) {\n          evaluated = {\n            name: expression,\n            status: new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, result.error, true)\n          };\n        } else {\n          // TODO: Determine how to not downcast this to v8.ValueMirror\n          // TODO: Handle the case where `result.mirror` is `undefined`.\n          evaluated = that.resolveVariable_(expression, result.mirror, true);\n          const varTableIdx = evaluated.varTableIndex;\n\n          if (typeof varTableIdx !== 'undefined') {\n            evalIndexSet.add(varTableIdx);\n          }\n        }\n\n        that.evaluatedExpressions[index2] = evaluated;\n      });\n    } // The frames are resolved after the evaluated expressions so that\n    // evaluated expressions can be evaluated as much as possible within\n    // the max data size limits\n\n\n    const frames = that.resolveFrames_(); // Now resolve the variables\n\n    let index = this.messageTable.length; // skip the sentinel values\n\n    const noLimit = that.config.capture.maxDataSize === 0;\n\n    while (index < that.rawVariableTable.length && ( // NOTE: length changes in loop\n    that.totalSize < that.config.capture.maxDataSize || noLimit)) {\n      assert.ok(!that.resolvedVariableTable[index]); // shouldn't have it\n      // resolved yet\n\n      const isEvaluated = evalIndexSet.has(index); // TODO: This code suggests that an ObjectMirror and Stutus are the\n      //       same.  Resolve this.\n\n      that.resolvedVariableTable[index] = that.resolveMirror_(that.rawVariableTable[index], isEvaluated);\n      index++;\n    } // If we filled up the buffer already, we need to trim the remainder\n\n\n    if (index < that.rawVariableTable.length) {\n      that.trimVariableTable_(index, frames);\n    }\n\n    return {\n      // TODO (fgao): Add path attribute to avoid explicit cast to\n      // stackdriver.SourceLocation once breakpoint is passed in this class.\n      id: 'dummy-id',\n      location: {\n        line: this.state.frame(0).sourceLine() + 1\n      },\n      stackFrames: frames,\n      variableTable: that.resolvedVariableTable,\n      evaluatedExpressions: that.evaluatedExpressions\n    };\n  }\n  /**\n   * Limits the size of the variable table to `fromIndex` elements. It marks\n   * all variables with entries beyond `fromIndex` with a message indicating\n   * that the table filled.\n   *\n   * @param {Number} fromIndex The desired size of the variable table.\n   * @param {Object} frames Frames associated with the current execution\n   *                        environment.\n   */\n\n\n  trimVariableTable_(fromIndex, frames) {\n    this.resolvedVariableTable.splice(fromIndex); // remove the remaining entries\n\n    const that = this;\n\n    const processBufferFull = variables => {\n      variables.forEach(variable => {\n        if (variable.varTableIndex && variable.varTableIndex >= fromIndex) {\n          // make it point to the sentinel 'buffer full' value\n          variable.varTableIndex = BUFFER_FULL_MESSAGE_INDEX;\n          variable.status = that.messageTable[BUFFER_FULL_MESSAGE_INDEX].status;\n        }\n\n        if (variable.members) {\n          processBufferFull(variable.members);\n        }\n      });\n    };\n\n    frames.forEach(frame => {\n      processBufferFull(frame.arguments);\n      processBufferFull(frame.locals);\n    });\n    processBufferFull(this.evaluatedExpressions);\n    processBufferFull(this.resolvedVariableTable);\n  }\n\n  resolveFrames_() {\n    const frames = [];\n    const frameCount = Math.min(this.state.frameCount(), this.config.capture.maxFrames);\n\n    for (let i = 0; i < frameCount; i++) {\n      const frame = this.state.frame(i);\n\n      if (this.shouldFrameBeResolved_(frame)) {\n        frames.push(this.resolveFrame_(frame, i < this.config.capture.maxExpandFrames));\n      }\n    }\n\n    return frames;\n  }\n\n  shouldFrameBeResolved_(frame) {\n    // Only capture data from the frames for which we can link the data back\n    // to the source files.\n    const fullPath = this.resolveFullPath_(frame);\n\n    if (!this.isPathInCurrentWorkingDirectory_(fullPath)) {\n      return false;\n    }\n\n    const relativePath = this.resolveRelativePath_(frame);\n\n    if (!this.config.capture.includeNodeModules && this.isPathInNodeModulesDirectory_(relativePath)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  resolveFullPath_(frame) {\n    const func = frame.func();\n\n    if (!func.resolved()) {\n      return '';\n    }\n\n    const script = func.script();\n\n    if (!script) {\n      return '';\n    }\n\n    return script.name();\n  }\n\n  resolveRelativePath_(frame) {\n    const fullPath = this.resolveFullPath_(frame);\n    return this.stripCurrentWorkingDirectory_(fullPath);\n  }\n\n  stripCurrentWorkingDirectory_(path) {\n    // Strip 1 extra character to remove the slash.\n    return path.substr(this.config.workingDirectory.length + 1);\n  }\n\n  isPathInCurrentWorkingDirectory_(path) {\n    // return true;\n    return path.indexOf(this.config.workingDirectory) === 0;\n  }\n\n  isPathInNodeModulesDirectory_(path) {\n    return path.indexOf('node_modules') === 0;\n  }\n\n  resolveFrame_(frame, underFrameCap) {\n    const args = []; // TODO: `locals` should be of type v8.ScopeMirror[]\n    //       Resolve conflicts so that it can be specified of that type.\n\n    let locals = []; // Locals and arguments are safe to collect even when\n    // `config.allowExpressions=false` since we properly avoid inspecting\n    // interceptors and getters by default.\n\n    if (!underFrameCap) {\n      args.push({\n        name: 'arguments_not_available',\n        varTableIndex: ARG_LOCAL_LIMIT_MESSAGE_INDEX\n      });\n      locals.push({\n        name: 'locals_not_available',\n        varTableIndex: ARG_LOCAL_LIMIT_MESSAGE_INDEX\n      });\n    } else {\n      // We will use the values aggregated from the ScopeMirror traversal stored\n      // in locals which will include any applicable arguments from the\n      // invocation.\n      locals = this.resolveLocalsList_(frame);\n\n      if (is_1.default.emptyArray(locals)) {\n        locals = [];\n      }\n    }\n\n    return {\n      function: this.resolveFunctionName_(frame.func()),\n      location: this.resolveLocation_(frame),\n      arguments: args,\n      locals\n    };\n  }\n\n  resolveFunctionName_(func) {\n    if (!func || !func.isFunction()) {\n      return '';\n    }\n\n    return func.name() || func.inferredName() || '(anonymous function)';\n  }\n\n  resolveLocation_(frame) {\n    return {\n      path: this.resolveRelativePath_(frame),\n      // V8 uses 0-based line numbers but Debuglet API uses 1-based numbers.\n      line: frame.sourceLine() + 1\n    };\n  }\n  /**\n   * Iterates and returns variable information for all scopes (excluding global)\n   * in a given frame. FrameMirrors should return their scope object list with\n   * most deeply nested scope first so variables initially encountered will take\n   * precedence over subsequent instance with the same name - this is tracked in\n   * the usedNames map. The argument list given to this function may be\n   * manipulated if variables with a deeper scope occur which have the same\n   * name.\n   * @function resolveLocalsList_\n   * @memberof StateResolver\n   * @param {FrameMirror} frame - A instance of FrameMirror\n   * @param {Array<Object>} args - An array of objects representing any function\n   *  arguments the frame may list\n   * @returns {Array<Object>} - returns an array containing data about selected\n   *  variables\n   */\n\n\n  resolveLocalsList_(frame) {\n    const self = this;\n    const usedNames = {};\n    const makeMirror = this.ctx.MakeMirror;\n    const allScopes = frame.allScopes();\n    const count = allScopes.length; // There will always be at least 3 scopes.\n    // For top-level breakpoints: [local, script, global]\n    // Other: [..., closure (module IIFE), script, global]\n\n    assert.ok(count >= 3);\n    assert.strictEqual(allScopes[count - 1].scopeType(), self.scopeType.Global);\n    assert.strictEqual(allScopes[count - 2].scopeType(), self.scopeType.Script); // We find the top-level (module global) variable pollute the local\n    // variables we omit them by default, unless the breakpoint itself is\n    // top-level. The last two scopes are always omitted.\n\n    let scopes;\n\n    if (allScopes[count - 3].scopeType() === self.scopeType.Closure) {\n      scopes = allScopes.slice(0, -3);\n    } else {\n      assert.ok(allScopes[count - 3].scopeType() === self.scopeType.Local);\n      scopes = allScopes.slice(0, -2);\n    }\n\n    const fromScopes = scopes.map(scope => {\n      const obj = scope.details().object();\n      return Object.keys(obj).reduce((acc, name) => {\n        const value = obj[name];\n        const trg = makeMirror(value);\n\n        if (!usedNames[name]) {\n          // It's a valid variable that belongs in the locals list\n          // and wasn't discovered at a lower-scope\n          usedNames[name] = true; // TODO: Determine how to not have an explicit down cast to\n          // ValueMirror\n\n          acc.push(self.resolveVariable_(name, trg, false));\n        }\n\n        return acc;\n      }, []);\n    });\n\n    function resolveFromReceiver() {\n      // The frame receiver is the 'this' context that is present during\n      // invocation. Check to see whether a receiver context is substantive,\n      // (invocations may be bound to null) if so: store in the locals list\n      // under the name 'context' which is used by the Chrome DevTools.\n      const ctx = frame.details().receiver();\n\n      if (ctx) {\n        // TODO: Determine how to not have an explicit down cast to\n        // ValueMirror\n        return [self.resolveVariable_('context', makeMirror(ctx), false)];\n      }\n\n      return [];\n    }\n\n    return [].concat(...fromScopes).concat(resolveFromReceiver());\n  }\n  /**\n   * Computes a text representation of the provided value based on its type.\n   * If the value is a recursive data type, it will be represented as an index\n   * into the variable table.\n   *\n   * @param {String} name The name of the variable.\n   * @param {Object} value A v8 debugger representation of a variable value.\n   * @param {boolean} isEvaluated Specifies if the variable is from a watched\n   *                              expression.\n   */\n\n\n  resolveVariable_(name, value, isEvaluated) {\n    let size = name.length;\n    const data = {\n      name\n    };\n\n    if (value.isPrimitive() || value.isRegExp()) {\n      // primitives: undefined, null, boolean, number, string, symbol\n      data.value = value.toText();\n      const maxLength = this.config.capture.maxStringLength;\n\n      if (!isEvaluated && maxLength && maxLength < data.value.length) {\n        data.status = new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, 'Only first `config.capture.maxStringLength=' + this.config.capture.maxStringLength + '` chars were captured for string of length ' + data.value.length + '. Use in an expression to see the full string.', false);\n        data.value = data.value.substring(0, maxLength) + '...';\n      }\n    } else if (value.isFunction()) {\n      // TODO: Determine how to resolve this so that a ValueMirror doesn't need\n      //       to be cast to a FunctionMirror.\n      data.value = 'function ' + this.resolveFunctionName_(value) + '()';\n    } else if (value.isObject()) {\n      data.varTableIndex = this.getVariableIndex_(value);\n    } else {\n      // PropertyMirror, InternalPropertyMirror, FrameMirror, ScriptMirror\n      data.value = 'unknown mirror type';\n    }\n\n    if (data.value) {\n      size += data.value.length;\n    } else {\n      size += 8; // fudge-it\n    }\n\n    this.totalSize += size;\n    return data;\n  }\n\n  getVariableIndex_(valueMirror) {\n    let idx = this.rawVariableTable.findIndex(rawVar => !!rawVar && rawVar.value() === valueMirror.value());\n\n    if (idx === -1) {\n      idx = this.storeObjectToVariableTable_(valueMirror);\n    }\n\n    return idx;\n  }\n\n  storeObjectToVariableTable_(obj) {\n    const idx = this.rawVariableTable.length;\n    this.rawVariableTable[idx] = obj;\n    return idx;\n  }\n  /**\n   * Responsible for recursively resolving the properties on a\n   * provided object mirror.\n   */\n\n\n  resolveMirror_(mirror, isEvaluated) {\n    let properties = mirror.properties();\n    const maxProps = this.config.capture.maxProperties;\n    const truncate = maxProps && properties.length > maxProps;\n\n    if (!isEvaluated && truncate) {\n      properties = properties.slice(0, maxProps);\n    } // TODO: It looks like `members` should be of type stackdriver.Variable[]\n    //       but is missing fields.  Determine if those fields are required or\n    //       if the type should not be stackdriver.Variable[]\n\n\n    const members = properties.map(this.resolveMirrorProperty_.bind(this, isEvaluated));\n\n    if (!isEvaluated && truncate) {\n      // TDOO: Determine how to remove this explicit cast\n      members.push({\n        name: 'Only first `config.capture.maxProperties=' + this.config.capture.maxProperties + '` properties were captured. Use in an expression' + ' to see all properties.'\n      });\n    }\n\n    return {\n      value: mirror.toText(),\n      members\n    };\n  }\n\n  resolveMirrorProperty_(isEvaluated, property) {\n    const name = String(property.name()); // Array length must be special cased as it is a native property that\n    // we know to be safe to evaluate which is not generally true.\n\n    const isArrayLen = property.mirror_.isArray() && name === 'length';\n\n    if (property.isNative() && !isArrayLen) {\n      return {\n        name,\n        varTableIndex: NATIVE_PROPERTY_MESSAGE_INDEX\n      };\n    }\n\n    if (property.hasGetter()) {\n      return {\n        name,\n        varTableIndex: GETTER_MESSAGE_INDEX\n      };\n    }\n\n    return this.resolveVariable_(name, property.value(), isEvaluated);\n  }\n\n} // This function is used by unit tests to make sure assertions are enabled.\n\n\nfunction testAssert() {\n  assert.strictEqual(0, 1);\n}\n\nexports.testAssert = testAssert;\n/**\n * Captures the stack and current execution state.\n *\n * @return an object with stackFrames, variableTable, and\n *         evaluatedExpressions fields\n */\n\nfunction capture(execState, expressions, config, v8debug) {\n  return new StateResolver(execState, expressions, config, v8debug).capture_();\n}\n\nexports.capture = capture;","map":null,"metadata":{},"sourceType":"script"}