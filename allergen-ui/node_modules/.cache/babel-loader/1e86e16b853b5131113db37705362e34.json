{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // TODO: Unify some common code with state.ts in future PRs.\n\nconst is_1 = require(\"@sindresorhus/is\");\n\nconst util = require(\"util\");\n\nconst status_message_1 = require(\"../../client/stackdriver/status-message\");\n\nconst debug_assert_1 = require(\"../util/debug-assert\");\n\nconst assert = debug_assert_1.debugAssert(!!process.env.CLOUD_DEBUG_ASSERTIONS); // Error message indices into the resolved variable table.\n\nconst BUFFER_FULL_MESSAGE_INDEX = 0;\nconst NATIVE_PROPERTY_MESSAGE_INDEX = 1;\nconst GETTER_MESSAGE_INDEX = 2;\nconst ARG_LOCAL_LIMIT_MESSAGE_INDEX = 3;\nconst FILE_PROTOCOL = 'file://';\nconst STABLE_OBJECT_ID_PROPERTY = '[[StableObjectId]]';\nconst NO_STABLE_OBJECT_ID = -1;\n/**\n * Checks that the provided expressions will not have side effects and\n * then evaluates the expression in the current execution context.\n *\n * @return an object with error and mirror fields.\n */\n\nfunction evaluate(expression, frame, v8inspector, returnByValue) {\n  // First validate the expression to make sure it doesn't mutate state\n  // and ask V8 Inspector to evaluate the expression\n  const result = v8inspector.evaluateOnCallFrame({\n    callFrameId: frame.callFrameId,\n    expression,\n    returnByValue,\n    throwOnSideEffect: true\n  });\n\n  if (result.error || !result.response) {\n    return {\n      error: result.error ? String(result.error) : 'no reponse in result'\n    };\n  } else if (result.response.exceptionDetails) {\n    return {\n      error: String(result.response.result.description).split('\\n')[0]\n    };\n  } else {\n    return {\n      error: null,\n      object: result.response.result\n    };\n  }\n}\n\nexports.evaluate = evaluate;\n\nclass StateResolver {\n  /**\n   * @param {Array<!Object>} callFrames\n   * @param {Array<string>} expressions\n   * @param {!Object} config\n   * @constructor\n   */\n  constructor(callFrames, breakpoint, config, scriptmapper, v8Inspector) {\n    this.callFrames = callFrames;\n    this.breakpoint = breakpoint; // TODO: Investigate whether this cast can be avoided.\n\n    this.expressions = breakpoint.expressions;\n    this.config = config;\n    this.scriptmapper = scriptmapper;\n    this.v8Inspector = v8Inspector;\n    this.evaluatedExpressions = [];\n    this.totalSize = 0;\n    this.messageTable = [];\n    this.messageTable[BUFFER_FULL_MESSAGE_INDEX] = {\n      status: new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, 'Max data size reached', true)\n    };\n    this.messageTable[NATIVE_PROPERTY_MESSAGE_INDEX] = {\n      status: new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, 'Native properties are not available', true)\n    };\n    this.messageTable[GETTER_MESSAGE_INDEX] = {\n      status: new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, 'Properties with getters are not available', true)\n    };\n    this.messageTable[ARG_LOCAL_LIMIT_MESSAGE_INDEX] = {\n      status: new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, 'Locals and arguments are only displayed for the ' + 'top `config.capture.maxExpandFrames=' + config.capture.maxExpandFrames + '` stack frames.', true)\n    }; // TODO: Determine why _extend is used here\n\n    this.resolvedVariableTable = util._extend([], this.messageTable);\n    this.rawVariableTable = this.messageTable.map(() => {\n      return null;\n    });\n  }\n  /**\n   * Captures the stack and current execution state.\n   *\n   * @return an object with stackFrames, variableTable, and\n   *         evaluatedExpressions fields\n   */\n\n\n  capture_() {\n    // Evaluate the watch expressions\n    const evalIndexSet = new Set();\n\n    if (this.expressions) {\n      this.expressions.forEach((expression, index2) => {\n        const result = evaluate(expression, this.callFrames[0], this.v8Inspector, false);\n        let evaluated;\n\n        if (result.error) {\n          evaluated = {\n            name: expression,\n            status: new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, result.error, true)\n          };\n        } else {\n          // TODO: Determine how to not downcast this to v8Types.ValueMirror\n          // TODO: Handle the case where `result.mirror` is `undefined`.\n          evaluated = this.resolveVariable_(expression, result.object, true);\n          const varTableIdx = evaluated.varTableIndex;\n\n          if (typeof varTableIdx !== 'undefined') {\n            evalIndexSet.add(varTableIdx);\n          }\n        }\n\n        this.evaluatedExpressions[index2] = evaluated;\n      });\n    } // The frames are resolved after the evaluated expressions so that\n    // evaluated expressions can be evaluated as much as possible within\n    // the max data size limits\n\n\n    const frames = this.resolveFrames_(); // Now resolve the variables\n\n    let index = this.messageTable.length; // skip the sentinel values\n\n    const noLimit = this.config.capture.maxDataSize === 0;\n\n    while (index < this.rawVariableTable.length && ( // NOTE: length changes in loop\n    this.totalSize < this.config.capture.maxDataSize || noLimit)) {\n      assert.ok(!this.resolvedVariableTable[index]); // shouldn't have it\n      // resolved yet\n\n      const isEvaluated = evalIndexSet.has(index); // TODO: Handle the cases where `null` or `undefined` occurs\n\n      if (this.rawVariableTable[index].objectId) {\n        this.resolvedVariableTable[index] = this.resolveRemoteObject_(this.rawVariableTable[index], isEvaluated);\n      }\n\n      index++;\n    } // If we filled up the buffer already, we need to trim the remainder\n\n\n    if (index < this.rawVariableTable.length) {\n      this.trimVariableTable_(index, frames);\n    }\n\n    return {\n      id: this.breakpoint.id,\n      stackFrames: frames,\n      variableTable: this.resolvedVariableTable,\n      evaluatedExpressions: this.evaluatedExpressions\n    };\n  }\n  /**\n   * Limits the size of the variable table to `fromIndex` elements. It marks\n   * all variables with entries beyond `fromIndex` with a message indicating\n   * that the table filled.\n   *\n   * @param {Number} fromIndex The desired size of the variable table.\n   * @param {Object} frames Frames associated with the current execution\n   *                        environment.\n   */\n\n\n  trimVariableTable_(fromIndex, frames) {\n    this.resolvedVariableTable.splice(fromIndex); // remove the remaining entries\n\n    const that = this;\n\n    const processBufferFull = variables => {\n      variables.forEach(variable => {\n        if (variable.varTableIndex && variable.varTableIndex >= fromIndex) {\n          // make it point to the sentinel 'buffer full' value\n          variable.varTableIndex = BUFFER_FULL_MESSAGE_INDEX;\n          variable.status = that.messageTable[BUFFER_FULL_MESSAGE_INDEX].status;\n        }\n\n        if (variable.members) {\n          processBufferFull(variable.members);\n        }\n      });\n    };\n\n    frames.forEach(frame => {\n      processBufferFull(frame.arguments);\n      processBufferFull(frame.locals);\n    });\n    processBufferFull(this.evaluatedExpressions);\n    processBufferFull(this.resolvedVariableTable);\n  }\n\n  resolveFrames_() {\n    const frames = [];\n    const frameCount = Math.min(this.callFrames.length, this.config.capture.maxFrames);\n\n    for (let i = 0; i < frameCount; i++) {\n      const frame = this.callFrames[i];\n\n      if (this.shouldFrameBeResolved_(frame)) {\n        frames.push(this.resolveFrame_(frame, i < this.config.capture.maxExpandFrames));\n      }\n    }\n\n    return frames;\n  }\n\n  shouldFrameBeResolved_(frame) {\n    // Only capture data from the frames for which we can link the data back\n    // to the source files.\n    const fullPath = this.resolveFullPath_(frame);\n\n    if (!this.isPathInCurrentWorkingDirectory_(fullPath)) {\n      return false;\n    }\n\n    const relativePath = this.resolveRelativePath_(frame);\n\n    if (!this.config.capture.includeNodeModules && this.isPathInNodeModulesDirectory_(relativePath)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  resolveFullPath_(frame) {\n    const scriptId = frame.location.scriptId;\n\n    if (this.scriptmapper[scriptId] === undefined) {\n      return '';\n    }\n\n    if (this.scriptmapper[scriptId].url === undefined) {\n      return '';\n    }\n\n    const scriptUrl = this.scriptmapper[scriptId].url; // In Node 11+, non-internal files are formatted as URLs, so get just the\n    // path.\n\n    return StateResolver.stripFileProtocol_(scriptUrl);\n  }\n\n  resolveRelativePath_(frame) {\n    const fullPath = this.resolveFullPath_(frame);\n    return this.stripCurrentWorkingDirectory_(fullPath);\n  }\n\n  static stripFileProtocol_(path) {\n    return path.toLowerCase().startsWith(FILE_PROTOCOL) ? path.substr(FILE_PROTOCOL.length) : path;\n  }\n\n  stripCurrentWorkingDirectory_(path) {\n    // Strip 1 extra character to remove the slash.\n    return StateResolver.stripFileProtocol_(path).substr(this.config.workingDirectory.length + 1);\n  }\n\n  isPathInCurrentWorkingDirectory_(path) {\n    return StateResolver.stripFileProtocol_(path).indexOf(this.config.workingDirectory) === 0;\n  }\n\n  isPathInNodeModulesDirectory_(path) {\n    return StateResolver.stripFileProtocol_(path).indexOf('node_modules') === 0;\n  }\n\n  resolveFrame_(frame, underFrameCap) {\n    const args = [];\n    let locals = [];\n\n    if (!underFrameCap) {\n      args.push({\n        name: 'arguments_not_available',\n        varTableIndex: ARG_LOCAL_LIMIT_MESSAGE_INDEX\n      });\n      locals.push({\n        name: 'locals_not_available',\n        varTableIndex: ARG_LOCAL_LIMIT_MESSAGE_INDEX\n      });\n    } else {\n      locals = this.resolveLocalsList_(frame);\n\n      if (is_1.default.emptyArray(locals)) {\n        locals = [];\n      }\n    }\n\n    return {\n      function: this.resolveFunctionName_(frame),\n      location: this.resolveLocation_(frame),\n      arguments: args,\n      locals\n    };\n  }\n\n  resolveFunctionName_(frame) {\n    if (!frame) {\n      return '';\n    }\n\n    if (frame.functionName === '') {\n      return '(anonymous function)';\n    }\n\n    return frame.functionName;\n  }\n\n  resolveLocation_(frame) {\n    return {\n      path: this.resolveRelativePath_(frame),\n      line: frame.location.lineNumber\n    };\n  }\n  /**\n   * Iterates and returns variable information for all scopes (excluding global)\n   * in a given frame. FrameMirrors should return their scope object list with\n   * most deeply nested scope first so variables initially encountered will take\n   * precedence over subsequent instance with the same name - this is tracked in\n   * the usedNames map. The argument list given to this function may be\n   * manipulated if variables with a deeper scope occur which have the same\n   * name.\n   * @function resolveLocalsList_\n   * @memberof StateResolver\n   * @param {inspector.Debugger.CallFrame} frame - A instance of callframe.\n   * @returns {Array<Object>} - returns an array containing data about selected\n   *  variables\n   */\n\n\n  resolveLocalsList_(frame) {\n    const locals = [];\n    const usedNames = {};\n    const allScopes = frame.scopeChain;\n    let count = allScopes.length; // We find the top-level (module global) variable pollute the local\n    // variables we omit them by default, unless the breakpoint itself is\n    // top-level. The last scope is always omitted.\n\n    if (frame.scopeChain[count - 2].type === 'closure') {\n      count -= 2;\n    } else {\n      count -= 1;\n    }\n\n    for (let i = 0; i < count; ++i) {\n      const result = this.v8Inspector.getProperties({\n        objectId: frame.scopeChain[i].object.objectId\n      }); // TODO: Handle when result.error exists.\n\n      if (result.response && !is_1.default.emptyArray(result.response.result)) {\n        for (let j = 0; j < result.response.result.length; ++j) {\n          if (!usedNames[result.response.result[j].name]) {\n            // It's a valid variable that belongs in the locals list\n            // and wasn't discovered at a lower-scope\n            usedNames[result.response.result[j].name] = true;\n\n            if (result.response.result[j].value) {\n              locals.push(this.resolveVariable_(result.response.result[j].name, result.response.result[j].value, false));\n            }\n          }\n        }\n      }\n    }\n\n    if (frame.this.objectId) {\n      locals.push(this.resolveVariable_('context', frame.this, false));\n    }\n\n    return locals;\n  }\n  /**\n   * Computes a text representation of the provided value based on its type.\n   * If the value is a recursive data type, it will be represented as an index\n   * into the variable table.\n   *\n   * @param {String} name The name of the variable.\n   * @param {Object} object A RemoteObject from v8 Runtime.\n   * @param {boolean} isEvaluated Specifies if the variable is from a watched\n   *                              expression.\n   */\n\n\n  resolveVariable_(name, object, isEvaluated) {\n    let size = name.length;\n    const data = {\n      name\n    };\n\n    if (this.isPrimitive_(object.type)) {\n      // primitives: undefined, null, boolean, number, string, symbol\n      data.value = String(object.value);\n      const maxLength = this.config.capture.maxStringLength;\n\n      if (!isEvaluated && maxLength && maxLength < data.value.length) {\n        data.status = new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, 'Only first `config.capture.maxStringLength=' + this.config.capture.maxStringLength + '` chars were captured for string of length ' + data.value.length + '. Use in an expression to see the full string.', false);\n        data.value = data.value.substring(0, maxLength) + '...';\n      }\n    } else if (this.isFunction_(object.type)) {\n      data.value = 'function ' + (name === '' ? '(anonymous function)' : name + '()');\n    } else if (this.isObject_(object.type)) {\n      data.varTableIndex = this.getVariableIndex_(object);\n    } else {\n      data.value = 'unknown type';\n    }\n\n    if (data.value) {\n      size += data.value.length;\n    } else {\n      size += 8; // fudge-it\n    }\n\n    this.totalSize += size;\n    return data;\n  }\n\n  isPrimitive_(type) {\n    return type === 'undefined' || type === 'boolean' || type === 'number' || type === 'string' || type === 'symbol';\n  }\n\n  isObject_(type) {\n    return type === 'object';\n  }\n\n  isFunction_(type) {\n    return type === 'function';\n  }\n  /**\n   * Gets the stable object ID for a given object, or NO_STABLE_OBJECT_ID\n   * if it can't be obtained.\n   * @param remoteObject The object whose stable object ID should be retrieved.\n   */\n\n\n  getStableObjectId(remoteObject) {\n    if (remoteObject.objectId === undefined) {\n      // Unexpected... but since this is required to obtain the stable object\n      // ID, return a value that specifies that it is not available.\n      return NO_STABLE_OBJECT_ID;\n    }\n\n    const properties = this.v8Inspector.getProperties({\n      objectId: remoteObject.objectId\n    });\n\n    if (properties.error || !properties.response || !properties.response.internalProperties) {\n      return NO_STABLE_OBJECT_ID;\n    }\n\n    const stableObjectIdProperty = properties.response.internalProperties.find(property => property.name === STABLE_OBJECT_ID_PROPERTY);\n\n    if (!stableObjectIdProperty || !stableObjectIdProperty.value || stableObjectIdProperty.value.value === undefined) {\n      return NO_STABLE_OBJECT_ID;\n    }\n\n    return stableObjectIdProperty.value.value;\n  }\n\n  getVariableIndex_(value) {\n    const stableObjectId = this.getStableObjectId(value);\n    let idx = this.rawVariableTable.findIndex(rawVar => {\n      if (rawVar) {\n        // stableObjectId was introduced in Node 10.15.3/11.7.0 as a more\n        // reliable way to check object equality, as objectId is unique only to\n        // object mirrors, and therefore monotonically increases on repeated\n        // accesses to the same remote object. If this field is available, use\n        // it.\n        if (stableObjectId !== NO_STABLE_OBJECT_ID) {\n          return rawVar.stableObjectId === stableObjectId;\n        } else {\n          // Fall back to using objectId for old versions of Node. Note that\n          // this will cause large data payloads for objects with circular\n          // references, and infinite loops if the max payload size is\n          // unlimited.\n          return rawVar.objectId === value.objectId;\n        }\n      }\n\n      return false;\n    });\n\n    if (idx === -1) {\n      idx = this.rawVariableTable.length;\n      this.rawVariableTable[idx] = {\n        objectId: value.objectId,\n        description: value.description,\n        stableObjectId\n      };\n    }\n\n    return idx;\n  }\n  /**\n   * Responsible for recursively resolving the properties on a\n   * provided remote object.\n   */\n\n\n  resolveRemoteObject_(object, isEvaluated) {\n    const maxProps = this.config.capture.maxProperties; // TS: ! is OK since getProperties will populate result.error in the absence\n    // of an object ID.\n\n    const result = this.v8Inspector.getProperties({\n      objectId: object.objectId\n    });\n    const members = [];\n\n    if (result.error || !result.response) {\n      members.push({\n        name: result.error ? String(result.error) : 'no response got in getProperty'\n      });\n    } else {\n      let truncate = maxProps && result.response.result.length > maxProps;\n      let upperBound = result.response.result.length;\n      if (!isEvaluated && truncate) upperBound = maxProps;\n\n      for (let i = 0; i < upperBound; ++i) {\n        if (result.response.result[i].isOwn) {\n          members.push(this.resolveObjectProperty_(isEvaluated, result.response.result[i]));\n        } else {\n          truncate = false;\n        }\n      }\n\n      if (!isEvaluated && truncate) {\n        members.push({\n          name: 'Only first `config.capture.maxProperties=' + this.config.capture.maxProperties + '` properties were captured. Use in an expression' + ' to see all properties.'\n        });\n      }\n    }\n\n    return {\n      value: object.description,\n      members\n    };\n  }\n\n  resolveObjectProperty_(isEvaluated, property) {\n    const name = String(property.name);\n\n    if (property.get !== undefined) {\n      return {\n        name,\n        varTableIndex: GETTER_MESSAGE_INDEX\n      };\n    } // TODO: Handle the case when property.value is undefined\n\n\n    return this.resolveVariable_(name, property.value, isEvaluated);\n  }\n\n} // This function is used by unit tests to make sure assertions are enabled.\n\n\nfunction testAssert() {\n  assert.strictEqual(0, 1);\n}\n\nexports.testAssert = testAssert;\n/**\n * Captures the stack and current execution state.\n *\n * @return an object with stackFrames, variableTable, and\n *         evaluatedExpressions fields\n */\n\nfunction capture(callFrames, breakpoint, config, scriptmapper, v8Inspector) {\n  return new StateResolver(callFrames, breakpoint, config, scriptmapper, v8Inspector).capture_();\n}\n\nexports.capture = capture;","map":null,"metadata":{},"sourceType":"script"}