{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Wraps a callback style function to conditionally return a promise.\n *\n * @param {function} originalMethod - The method to promisify.\n * @param {object=} options - Promise options.\n * @param {boolean} options.singular - Resolve the promise with single arg instead of an array.\n * @return {function} wrapped\n */\n\nfunction promisify(originalMethod, options) {\n  if (originalMethod.promisified_) {\n    return originalMethod;\n  }\n\n  options = options || {};\n  const slice = Array.prototype.slice; // tslint:disable-next-line:no-any\n\n  const wrapper = function () {\n    const context = this;\n    let last;\n\n    for (last = arguments.length - 1; last >= 0; last--) {\n      const arg = arguments[last];\n\n      if (typeof arg === 'undefined') {\n        continue; // skip trailing undefined.\n      }\n\n      if (typeof arg !== 'function') {\n        break; // non-callback last argument found.\n      }\n\n      return originalMethod.apply(context, arguments);\n    } // peel trailing undefined.\n\n\n    const args = slice.call(arguments, 0, last + 1); // tslint:disable-next-line:variable-name\n\n    let PromiseCtor = Promise; // Because dedupe will likely create a single install of\n    // @google-cloud/common to be shared amongst all modules, we need to\n    // localize it at the Service level.\n\n    if (context && context.Promise) {\n      PromiseCtor = context.Promise;\n    }\n\n    return new PromiseCtor((resolve, reject) => {\n      // tslint:disable-next-line:no-any\n      args.push((...args) => {\n        const callbackArgs = slice.call(args);\n        const err = callbackArgs.shift();\n\n        if (err) {\n          return reject(err);\n        }\n\n        if (options.singular && callbackArgs.length === 1) {\n          resolve(callbackArgs[0]);\n        } else {\n          resolve(callbackArgs);\n        }\n      });\n      originalMethod.apply(context, args);\n    });\n  };\n\n  wrapper.promisified_ = true;\n  return wrapper;\n}\n\nexports.promisify = promisify;\n/**\n * Promisifies certain Class methods. This will not promisify private or\n * streaming methods.\n *\n * @param {module:common/service} Class - Service class.\n * @param {object=} options - Configuration object.\n */\n// tslint:disable-next-line:variable-name\n\nfunction promisifyAll(Class, options) {\n  const exclude = options && options.exclude || [];\n  const ownPropertyNames = Object.getOwnPropertyNames(Class.prototype);\n  const methods = ownPropertyNames.filter(methodName => {\n    // clang-format off\n    return typeof Class.prototype[methodName] === 'function' && // is it a function?\n    !/(^_|(Stream|_)|promise$)|^constructor$/.test(methodName) && // is it promisable?\n    exclude.indexOf(methodName) === -1; // is it blacklisted?\n    // clang-format on\n  });\n  methods.forEach(methodName => {\n    const originalMethod = Class.prototype[methodName];\n\n    if (!originalMethod.promisified_) {\n      Class.prototype[methodName] = exports.promisify(originalMethod, options);\n    }\n  });\n}\n\nexports.promisifyAll = promisifyAll;\n/**\n * Wraps a promisy type function to conditionally call a callback function.\n *\n * @param {function} originalMethod - The method to callbackify.\n * @param {object=} options - Callback options.\n * @param {boolean} options.singular - Pass to the callback a single arg instead of an array.\n * @return {function} wrapped\n */\n\nfunction callbackify(originalMethod) {\n  if (originalMethod.callbackified_) {\n    return originalMethod;\n  } // tslint:disable-next-line:no-any\n\n\n  const wrapper = function () {\n    const context = this;\n\n    if (typeof arguments[arguments.length - 1] !== 'function') {\n      return originalMethod.apply(context, arguments);\n    }\n\n    const cb = Array.prototype.pop.call(arguments);\n    originalMethod.apply(context, arguments).then( // tslint:disable-next-line:no-any\n    res => {\n      res = Array.isArray(res) ? res : [res];\n      cb(null, ...res);\n    }, err => cb(err));\n  };\n\n  wrapper.callbackified_ = true;\n  return wrapper;\n}\n\nexports.callbackify = callbackify;\n/**\n * Callbackifies certain Class methods. This will not callbackify private or\n * streaming methods.\n *\n * @param {module:common/service} Class - Service class.\n * @param {object=} options - Configuration object.\n */\n\nfunction callbackifyAll( // tslint:disable-next-line:variable-name\nClass, options) {\n  const exclude = options && options.exclude || [];\n  const ownPropertyNames = Object.getOwnPropertyNames(Class.prototype);\n  const methods = ownPropertyNames.filter(methodName => {\n    // clang-format off\n    return typeof Class.prototype[methodName] === 'function' && // is it a function?\n    !/^_|(Stream|_)|^constructor$/.test(methodName) && // is it callbackifyable?\n    exclude.indexOf(methodName) === -1; // is it blacklisted?\n    // clang-format on\n  });\n  methods.forEach(methodName => {\n    const originalMethod = Class.prototype[methodName];\n\n    if (!originalMethod.callbackified_) {\n      Class.prototype[methodName] = exports.callbackify(originalMethod);\n    }\n  });\n}\n\nexports.callbackifyAll = callbackifyAll;","map":null,"metadata":{},"sourceType":"script"}